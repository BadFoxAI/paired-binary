<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paired Binary Interactive Explorer</title>
    <style>
        :root {
            --primary-color: #3f51b5; /* Indigo */
            --primary-dark: #303f9f;
            --primary-darker: #283593;
            --accent-color: #2ecc71; /* Green */
            --accent-dark: #27ae60;
            --background-color: #f0f4f8; /* Light Blue-Grey */
            --surface-color: #ffffff;
            --text-color: #212529;
            --muted-text-color: #6c757d;
            --border-color: #dee2e6;
            --input-bg-color: #f8f9fa;
            --status-ok-bg: #d1e7dd;
            --status-ok-text: #0f5132;
            --status-error-bg: #f8d7da;
            --status-error-text: #842029;
            --status-info-bg: #cff4fc;
            --status-info-text: #055160;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; padding: 20px; background-color: var(--background-color);
            color: var(--text-color); line-height: 1.6; display: flex; flex-direction: column; align-items: center;
        }
        .main-container {
            width: 100%; max-width: 960px; background-color: var(--surface-color);
            padding: 25px 30px; border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,0.08);
            border: 1px solid var(--border-color);
        }
        h1, h2, h3 { color: var(--primary-dark); text-align: center; }
        h1 { font-size: 2.4em; margin-bottom: 15px; font-weight: 600;}
        h2 { font-size: 1.75em; margin-top: 35px; margin-bottom: 20px; border-bottom: 2px solid var(--primary-color); padding-bottom: 8px; font-weight: 600;}
        h3 { margin-top: 25px; margin-bottom: 15px; text-align:left; font-size: 1.3em; color: var(--primary-dark); font-weight: 600;}

        .status-panel { text-align: center; margin-bottom: 25px; padding: 12px; border-radius: 6px; font-weight: 500; border: 1px solid transparent; }
        .status-ok { background-color: var(--status-ok-bg); color: var(--status-ok-text); border-color: var(--status-ok-text); }
        .status-error { background-color: var(--status-error-bg); color: var(--status-error-text); border-color: var(--status-error-text); }
        .status-info { background-color: var(--status-info-bg); color: var(--status-info-text); border-color: var(--status-info-text); }

        .primary-visualization, .key-benchmark, .advanced-section {
            padding: 20px; margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px; background-color: #fcfdff; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .primary-visualization p, .key-benchmark p { text-align: center; margin-bottom: 18px; color: var(--muted-text-color); font-size: 0.95em;}
        
        #evolutionSvgContainer { 
            text-align: center; 
            overflow: hidden; 
            width: 600px; 
            height: 400px; 
            margin: 15px auto; 
            border: 1px solid var(--border-color); 
            cursor: grab; 
            position: relative; 
            background-color: #2c3e50; 
            border-radius: 4px;
        }
        #evolutionSvg { 
            display: block; 
        }
        .evolution-controls { text-align:center; margin-bottom:15px; }
        .evolution-controls label, .evolution-controls input, .evolution-controls button {
            margin-right: 8px; margin-left: 8px;
            vertical-align: middle;
            margin-bottom: 8px; 
        }
        .evolution-controls input[type="number"] { width: 70px; padding: 8px; font-size:0.9em;}
        .evolution-controls button { width: auto; padding: 8px 15px; font-size:0.9em; }

        button {
            background-color: var(--primary-color); color: white;
            padding: 12px 22px; border: none; border-radius: 5px;
            cursor: pointer; font-size: 1em; font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-block; margin: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover { background-color: var(--primary-dark); transform: translateY(-1px); }
        button:active { background-color: var(--primary-darker); transform: translateY(0px); }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; transform: translateY(0); opacity: 0.7; }
        button.secondary-action { background-color: #78909c; }
        button.secondary-action:hover { background-color: #607d8b; }
        button.test-suite-button { background-color: var(--accent-color); }
        button.test-suite-button:hover { background-color: var(--accent-dark); }

        details {
            background-color: #f8f9fa; border: 1px solid var(--border-color);
            border-radius: 6px; margin-top: 30px;
        }
        summary {
            font-weight: 600; font-size: 1.25em; color: var(--primary-dark);
            padding: 15px 20px; cursor: pointer; background-color: #eef2f7; 
            border-radius: 6px; transition: background-color 0.2s ease;
            list-style-position: inside; 
        }
        details[open] summary { border-bottom: 1px solid var(--border-color); border-radius: 6px 6px 0 0;}
        summary:hover { background-color: #d6e0f0; }
        .details-content { padding: 25px; background-color: var(--surface-color); border-radius: 0 0 6px 6px;}

        .control-group { margin-bottom: 18px; padding: 12px; border-radius: 5px; background-color: #fdfdff; border: 1px solid #f0f0f0;}
        .control-group label { display: block; margin-bottom: 6px; font-weight: 500; color: #495057; font-size: 0.95em; }
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group select {
            width: calc(100% - 24px); padding: 10px; margin-bottom: 10px;
            border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; font-size: 1em;
            background-color: var(--input-bg-color);
        }
        .control-group input[type="text"]:focus,
        .control-group input[type="number"]:focus,
        .control-group select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(63, 81, 181, 0.25);
            outline: none;
        }
        .control-group button { width: auto; font-size: 0.95em; padding: 8px 18px; }

        #mainOutputArea, #benchmarkResultArea {
            margin-top: 18px; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px;
            background-color: #eef2f7; min-height: 45px; font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap; font-size: 0.95em; overflow-wrap: break-word;
        }
        #fullLogContainer { margin-top: 30px;}
        #fullOutputLog { display:none; width: 100%; height: 300px; font-family: 'Courier New', Courier, monospace; font-size: 0.85em; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; box-sizing: border-box; background-color: #f8f9fa; white-space: pre-wrap; overflow-y: auto; margin-top: 10px;}
        .log-controls { margin-bottom: 10px; text-align: center; }
        .log-controls button { margin: 5px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Paired Binary Interactive Explorer</h1>
        <div id="wasmStatus" class="status-panel status-info">Loading WASM...</div>
        <div id="mainOutputArea"><p><i>Status and results of primary actions will appear here.</i></p></div>

        <section class="primary-visualization">
            <h2>Generative Evolution Plot</h2>
            <p>Visualizes randomly generated S<sub>N</sub> Paired Entities (X and X') appearing over time. Coordinates derived from S_base components of X.
               (Ensure Propagator is set in Advanced Controls - defaults to S3={0,1,2}).</p>
            <div class="evolution-controls">
                <label for="evoNLevel">N-Level:</label>
                <input type="number" id="evoNLevel" value="12" min="6" step="3"> 
                <label for="evoMaxPoints">Max Points:</label>
                <input type="number" id="evoMaxPoints" value="100" min="10">
                <br>
                <label for="evoSpeed">Speed (ms/dot):</label>
                <input type="number" id="evoSpeed" value="200" min="10" style="width:70px;">
                
                <button onclick="toggleEvolutionPlot()" id="playPauseEvoButton">Play</button>
                <button onclick="stepForwardEvolution()" id="stepEvoButton" title="Step Forward">▶︎|</button>
                <button onclick="increaseEvolutionSpeed()" id="ffEvoButton" title="Faster">FF »</button>
                <button onclick="decreaseEvolutionSpeed()" id="slowEvoButton" title="Slower">« Slow</button>
                <button onclick="clearEvolutionPlot()" class="secondary-action">Clear & Reset</button>
            </div>
            <div id="evolutionSvgContainer">
                <svg id="evolutionSvg" width="600" height="400" xmlns="http://www.w3.org/2000/svg">
                    <g id="evoPlotMasterGroup"></g>
                </svg>
            </div>
        </section>

        <section class="key-benchmark">
            <h2>Key Performance Metric</h2>
            <p>Test how large 'N' can be for `generate_random_member` + `is_member` to complete within a target time.
               (This test temporarily sets S_base to {0,1,2}, N_base=3 for consistency.)</p>
            <label for="depthTestTimeLimit">Time Limit per N (ms):</label>
            <input type="number" id="depthTestTimeLimit" value="500" style="width:100px; display:inline-block; margin-right:10px;">
            <button onclick="runDepthTest()" id="depthTestButton">Run Max N Depth Test</button>
            <div id="benchmarkResultArea" style="margin-top:15px;"><p><i>Depth test results will appear here.</i></p></div>
        </section>

        <details id="advancedControlsDetails">
            <summary>Advanced Controls & Detailed Tests »</summary>
            <div class="details-content">
                <h2>Propagator Setup</h2>
                <div class="control-group">
                    <label for="sBaseValuesInput">S_base Values (comma-separated decimal strings):</label>
                    <input type="text" id="sBaseValuesInput" value="0,1,2">
                    <label for="nBaseBitsInput">N_base Bits:</label>
                    <input type="number" id="nBaseBitsInput" value="3" min="1">
                    <button onclick="setupWasmPropagator()">Initialize / Update Propagator</button>
                </div>

                <h2>Automated Basic Tests</h2>
                <div class="control-group">
                    <button class="test-suite-button" onclick="runAutomatedTests()">Run Basic Logic Test Suite</button>
                </div>
                
                <h2>Performance Tests (Manual)</h2>
                <div class="control-group">
                    <h3>Run Speed Test</h3>
                    <label for="perfTestFunction">Function to Test:</label>
                    <select id="perfTestFunction">
                        <option value="is_member">is_member</option>
                        <option value="decompose_to_base">decompose_to_base</option>
                        <option value="compose_from_base">compose_from_base</option>
                        <option value="generate_random_member">generate_random_member</option>
                        <option value="create_paired_entity">create_paired_entity</option>
                    </select>
                    <label for="perfTestNValue">Target N-bits:</label>
                    <input type="number" id="perfTestNValue" value="12">
                     <label for="perfTestXValue">X Value for test (if applicable):</label>
                    <input type="text" id="perfTestXValue" value="0">
                    <label for="perfTestIterations">Number of Iterations:</label>
                    <input type="number" id="perfTestIterations" value="1000">
                    <button onclick="runPerformanceTest()">Start Manual Perf Test</button>
                </div>

                <h2>Manual Function Tests</h2>
                <div class="control-group">
                    <h3>Create Paired Entity</h3>
                    <label for="peXValueInput">X Value (decimal string):</label>
                    <input type="text" id="peXValueInput" value="2">
                    <label for="peNBitsInput">N-bits:</label>
                    <input type="number" id="peNBitsInput" value="3" min="1">
                    <button onclick="runCreatePairedEntity()">Create Paired Entity</button>
                </div>
                <div class="control-group">
                    <h3>Test S_N Membership</h3>
                    <label for="memberXValueInput">X Value (decimal string):</label>
                    <input type="text" id="memberXValueInput" value="18">
                    <label for="memberNBitsInput">Target N-bits:</label>
                    <input type="number" id="memberNBitsInput" value="6" min="1">
                    <button onclick="runIsMember()">Test Membership</button>
                </div>
                <div class="control-group">
                     <h3>Decompose to S_base</h3>
                    <label for="decomposeXValueInput">X Value (decimal string):</label>
                    <input type="text" id="decomposeXValueInput" value="18">
                    <label for="decomposeNBitsInput">Target N-bits:</label>
                    <input type="number" id="decomposeNBitsInput" value="6" min="1">
                    <button onclick="runDecompose()">Decompose</button>
                </div>
                <div class="control-group">
                    <h3>Compose from S_base</h3>
                    <label for="composeComponentsInput">S_base Components (comma-separated decimal strings):</label>
                    <input type="text" id="composeComponentsInput" value="2,2">
                    <button onclick="runCompose()">Compose</button>
                </div>
                <div class="control-group">
                    <h3>Generate Random S_N Member</h3>
                    <label for="randomNBitsInput">Target N-bits:</label>
                    <input type="number" id="randomNBitsInput" value="6" min="1">
                    <label for="randomSeedOffsetInput">Seed Offset (for PRNG consistency):</label>
                    <input type="number" id="randomSeedOffsetInput" value="0">
                    <button onclick="runGenerateRandom()">Generate Random</button>
                </div>
            </div>
        </details>

        <div id="fullLogContainer">
            <h2>Verbose Log</h2>
            <div class="log-controls">
                <button onclick="toggleFullLog()" class="secondary-action">Toggle Full Log Display</button>
                <button onclick="exportFullLog()" class="secondary-action">Export Full Log</button>
                <button onclick="clearFullLog()" class="secondary-action">Clear Full Log</button>
            </div>
            <textarea id="fullOutputLog" readonly></textarea>
        </div>
    </div>

    <script type="module">
        // These will be assigned after WASM is loaded
        let setup_propagator_wasm, is_member_wasm, decompose_to_base_wasm, compose_from_base_wasm,
            generate_random_member_wasm, create_paired_entity_wasm;

        // Import and assign to global lexical variables
        import init, * as wasm_exports from './pkg/paired_binary.js';

        const mainOutputArea = document.getElementById('mainOutputArea');
        const benchmarkResultArea = document.getElementById('benchmarkResultArea');
        const fullOutputLog = document.getElementById('fullOutputLog');
        const wasmStatusDiv = document.getElementById('wasmStatus');
        const evolutionSvgElement = document.getElementById('evolutionSvg');
        const evoPlotMasterGroup = document.getElementById('evoPlotMasterGroup');
        const SVG_NS = "http://www.w3.org/2000/svg";
        
        let wasmInitialized = false;
        let currentSBaseForDisplay = "0,1,2"; 
        let currentNBaseForDisplay = 3;
        let isBenchmarking = false; 
        
        let evolutionAnimationId = null;
        let evolutionPoints = [];
        let evoPlotSettings = {
            nLevel: 12, maxPoints: 100, speed: 200, currentSpeed: 200, speedMultiplier: 1,
            sBaseCache: [0,1,2], nBaseCache: 3, isRunning: false
        };
        let evoViewBox = { x: 0, y: 0, width: 600, height: 400 }; 
        let evoZoomLevel = 1;
        let evoIsPanning = false;
        let evoLastPanPosition = { x: 0, y: 0 };

        function displayMain(message, type = "info") {
            mainOutputArea.innerHTML = `<p class="status-panel status-${type}">${message}</p>`;
            if (type === "error") console.error("MainDisplay:", message);
            else console.log("MainDisplay:", message);
        }

        function verboseLog(message, context = "Generic") {
            console.log(`[${context}]`, message);
            const timestamp = new Date().toLocaleTimeString();
            const currentLogVal = fullOutputLog.value;
            const maxLogLength = 50000; 
            const entry = `${timestamp}: [${context}] ${typeof message === 'string' ? message : JSON.stringify(message, null, 2)}\n\n`;
            fullOutputLog.value = (currentLogVal + entry).slice(-maxLogLength);
            if (fullOutputLog.style.display !== 'none') {
                fullOutputLog.scrollTop = fullOutputLog.scrollHeight;
            }
        }
        
        async function initializeWasm() {
            if (wasmInitialized) return true;
            wasmStatusDiv.textContent = "Loading WASM...";
            wasmStatusDiv.className = "status-panel status-info";
            try {
                await init(); 
                setup_propagator_wasm = wasm_exports.setup_propagator;
                is_member_wasm = wasm_exports.is_member;
                decompose_to_base_wasm = wasm_exports.decompose_to_base;
                compose_from_base_wasm = wasm_exports.compose_from_base;
                generate_random_member_wasm = wasm_exports.generate_random_member;
                create_paired_entity_wasm = wasm_exports.create_paired_entity;

                wasmStatusDiv.textContent = "WASM Module Initialized Successfully.";
                wasmStatusDiv.className = "status-panel status-ok";
                verboseLog("WASM module initialized successfully.", "System");
                wasmInitialized = true;
                try { 
                    setup_propagator_wasm("0,1,2", 3); 
                    currentSBaseForDisplay = "0,1,2";
                    currentNBaseForDisplay = 3;
                    verboseLog("Default propagator S3={0,1,2} initialized.", "System");
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`Error setting up default propagator: ${errorStr}`, "System");
                    displayMain(`Error setting up default propagator: ${errorStr}`, "error");
                }
                // Ensure buttons are correctly enabled/disabled after WASM load
                if (document.getElementById('stopEvoButton')) document.getElementById('stopEvoButton').disabled = true;
                if (document.getElementById('playPauseEvoButton')) document.getElementById('playPauseEvoButton').textContent = 'Play';
                if (document.getElementById('stepEvoButton')) document.getElementById('stepEvoButton').disabled = false;
                
                applyEvoViewTransform(); 
                if (evolutionSvgElement) evolutionSvgElement.style.cursor = 'grab'; // Set only if element exists

                return true;
            } catch (e) {
                wasmStatusDiv.textContent = "WASM Initialization Failed! Check console.";
                wasmStatusDiv.className = "status-panel status-error";
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                verboseLog(`WASM Initialization Failed: ${errorStr}`, "System");
                wasmInitialized = false;
                return false;
            }
        }
        
        window.setupWasmPropagator = async () => { 
            if (!await initializeWasm()) return;
            const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
            const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
            currentSBaseForDisplay = sBaseValuesStr; 
            currentNBaseForDisplay = nBaseBits;
            try {
                setup_propagator_wasm(sBaseValuesStr, nBaseBits);
                displayMain(`Propagator initialized/updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "ok");
                verboseLog(`Propagator user-updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "Setup");
                evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                evoPlotSettings.nBaseCache = currentNBaseForDisplay;
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`Setup Propagator Error: ${errorStr}`, "error");
                verboseLog(`Error setting up propagator: ${errorStr}`, "Setup");
            }
        };
        
        async function runWasmOpForDisplay(actionName, operationFunc, ...args) {
            if (!await initializeWasm()) return "WASM not ready";
            displayMain(`${actionName}: Processing...`, "info");
            const startTime = performance.now();
            try {
                const result = await operationFunc(...args); 
                const endTime = performance.now();
                const timedResult = { result: result, time_ms: (endTime - startTime).toFixed(3) };
                displayMain(`${actionName} Complete.`, "ok"); 
                verboseLog({action: actionName, inputs: args.map(String), ...timedResult}, "ManualOp");
                return result; 
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`${actionName} Error: ${errorStr}`, "error");
                verboseLog(`Error in ${actionName}: ${errorStr}`, "ManualOp");
                throw e; 
            }
        }

        window.runCreatePairedEntity = () => { 
            const x = document.getElementById('peXValueInput').value;
            const n = parseInt(document.getElementById('peNBitsInput').value);
            runWasmOpForDisplay("CreatePairedEntity", create_paired_entity_wasm, x, n);
        };
        window.runIsMember = () => { 
            const x = document.getElementById('memberXValueInput').value;
            const n = parseInt(document.getElementById('memberNBitsInput').value);
            runWasmOpForDisplay("IsMember", is_member_wasm, x, n);
        };
        window.runDecompose = async () => { 
            const x = document.getElementById('decomposeXValueInput').value;
            const n = parseInt(document.getElementById('decomposeNBitsInput').value);
            await runWasmOpForDisplay("Decompose", async (val, bits) => {
                 const wasm_array = decompose_to_base_wasm(val, bits);
                 const nativeJsArray = Array.from(wasm_array);
                 return nativeJsArray.map(jsValToString);
            }, x, n);
        };
        window.runCompose = () => { 
            const compsStr = document.getElementById('composeComponentsInput').value;
            const compsArr = compsStr.split(',').map(s => s.trim()).filter(s => s.length > 0);
            runWasmOpForDisplay("Compose", compose_from_base_wasm, compsArr);
        };
        window.runGenerateRandom = () => { 
            const n = parseInt(document.getElementById('randomNBitsInput').value);
            const seed = parseInt(document.getElementById('randomSeedOffsetInput').value);
            runWasmOpForDisplay("GenerateRandom", generate_random_member_wasm, n, seed);
        };

        window.runAutomatedTests = async () => {
            if (!await initializeWasm()) return;
            displayMain("Automated Tests", "Running... Check verbose log for details.", "info");
            verboseLog("Starting Automated Basic Test Suite...", "TestRunner");
            try { setup_propagator_wasm("0,1,2", 3); } catch(e) { verboseLog("Failed to set S3={0,1,2} for tests", "TestRunner"); displayMain("Automated Tests Error: Could not set S3.", "error"); return;}

            const tests = [
                { name: "PE_N3_X2", func: () => create_paired_entity_wasm("2", 3), expect: (r) => r.x === "2" && r.x_prime === "5" && r.n_bits === 3 },
                { name: "IsMember_S6_18_True", func: () => is_member_wasm("18", 6), expect: (r) => r === true },
                { name: "Decompose_S6_18", func: () => decompose_to_base_wasm("18", 6), expect: (r_arr) => Array.from(r_arr).map(jsValToString).join(',') === "2,2" },
                { name: "Compose_S6_From_[2,2]", func: () => compose_from_base_wasm(["2","2"]), expect: (r) => r.value === "18" && r.n_bits === 6 },
                { name: "GenRandom_S6_Valid", func: async () => { const r_str = await generate_random_member_wasm(6, 10); return {randomVal: r_str, isMember: await is_member_wasm(r_str, 6)}; }, expect: (res) => res.isMember === true && !isNaN(parseInt(res.randomVal)) },
            ];
            let testsPassed = 0; let testsFailed = 0;
            const suiteStartTime = performance.now();
            for (const test of tests) {
                verboseLog(`Running test: ${test.name}`, "TestRunner");
                let result, errorOccurred = false, actualError = null;
                try { result = await test.func(); } 
                catch (e) { errorOccurred = true; actualError = e; }

                if (test.expectError) {
                    if (errorOccurred) { verboseLog(`PASS: ${test.name}`, "TestRunner"); testsPassed++; } 
                    else { verboseLog(`FAIL: ${test.name} - Expected error, got success: ${JSON.stringify(result)}`, "TestRunner"); testsFailed++; }
                } else {
                    if (errorOccurred) { verboseLog(`FAIL: ${test.name} - Expected success, got error: ${String(actualError)}`, "TestRunner"); testsFailed++; } 
                    else {
                        let assertionPassed = false; try { assertionPassed = test.expect(result); } catch (ae) { verboseLog(`FAIL: ${test.name} - Assertion func error: ${ae}`, "TestRunner");}
                        if (assertionPassed) { verboseLog(`PASS: ${test.name}`, "TestRunner"); testsPassed++; } 
                        else { verboseLog(`FAIL: ${test.name} - Assertion failed. Got: ${JSON.stringify(result)}`, "TestRunner"); testsFailed++; }
                    }
                }
            }
            const suiteEndTime = performance.now();
            const totalSuiteTime = (suiteEndTime - suiteStartTime).toFixed(3);
            const summary = `Test Suite: ${testsPassed} passed, ${testsFailed} failed in ${totalSuiteTime} ms.`;
            displayMain("Automated Tests", summary + (testsFailed > 0 ? " Check verbose log for details." : " All OK!"), testsFailed > 0 ? "error" : "ok");
            verboseLog(summary, "TestRunner");
        };
        
        window.runDepthTest = async () => {
            if (!await initializeWasm()) return;
            if (isBenchmarking) { displayMain("Depth Test", "Benchmark already in progress.", "info"); return; }
            isBenchmarking = true;
            const depthTestButton = document.getElementById("depthTestButton");
            depthTestButton.disabled = true; depthTestButton.textContent = "Running Depth Test...";
            benchmarkResultArea.innerHTML = "<p><i>Running depth test... This may take some time. Please wait.</i></p>";
            verboseLog("Starting Max N Depth Test...", "DepthTest");

            const requiredSBase = "0,1,2"; const requiredNBase = 3;
            if (currentSBaseForDisplay !== requiredSBase || currentNBaseForDisplay !== requiredNBase) {
                try { 
                    setup_propagator_wasm(requiredSBase, requiredNBase); 
                    currentSBaseForDisplay = requiredSBase; currentNBaseForDisplay = requiredNBase;
                    verboseLog(`Propagator reset to S_base=${requiredSBase}, N_base=${requiredNBase} for depth test.`, "DepthTest-Setup");
                } catch(e) { 
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    benchmarkResultArea.innerHTML = `<p class="status-panel status-error">Error setting up S3={0,1,2} for test: ${errorStr}</p>`; 
                    isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test"; return;
                }
            }

            const timeLimitMs = parseInt(document.getElementById('depthTestTimeLimit').value) || 500;
            let currentN = requiredNBase * 2; 
            let maxNReached = 0; let results = [];
            const practicalBrowserNLimit = 4096; 

            while (currentN <= practicalBrowserNLimit) {
                verboseLog(`DepthTest: Testing N=${currentN}`, "DepthTest");
                let xValStr; let duration = 0; let isMem = false; let testPassedThisN = false;
                try {
                    const stepStartTime = performance.now();
                    xValStr = await generate_random_member_wasm(currentN, Date.now() % 1000 + currentN); 
                    if (typeof xValStr !== 'string' || xValStr.length === 0) throw new Error("generate_random_member_wasm invalid output.");
                    isMem = await is_member_wasm(xValStr, currentN);
                    const stepEndTime = performance.now();
                    duration = stepEndTime - stepStartTime;
                    const xPreview = xValStr.length > 20 ? xValStr.slice(0, 20) + "..." : xValStr;
                    results.push({ N: currentN, time_ms: duration.toFixed(3), is_member_result: isMem, generated_x_preview: xPreview });
                    if (duration <= timeLimitMs) { maxNReached = currentN; testPassedThisN = true; } 
                    else { verboseLog(`DepthTest: N=${currentN} exceeded time limit (${duration.toFixed(2)}ms > ${timeLimitMs}ms). Stopping.`, "DepthTest"); break; }
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`DepthTest: Error at N=${currentN}: ${errorStr}`, "DepthTest");
                    results.push({ N: currentN, time_ms: duration.toFixed(3), error: errorStr, generated_x_preview: "ERROR_DURING_GEN/TEST" });
                    if (!errorStr.includes("InvalidHierarchicalLevel")) { maxNReached = currentN > requiredNBase ? currentN / 2 : 0; verboseLog(`DepthTest: Stopping due to error at N=${currentN}. Last N for gen: ${maxNReached}.`, "DepthTest"); break; }
                }
                if (!testPassedThisN) break; 
                if (currentN >= practicalBrowserNLimit / 2 && currentN < practicalBrowserNLimit) { if (currentN * 2 > practicalBrowserNLimit) break; }
                currentN *= 2; 
            }
            benchmarkResultArea.innerHTML = `<h3>Depth Test Results (S_base=${requiredSBase}, N_base=${requiredNBase}):</h3> <p>Max N reached for (generate_random + is_member) within ~${timeLimitMs}ms per N: <b>${maxNReached || 'N_base only (or error)'}</b></p> <pre>${JSON.stringify(results, null, 2)}</pre>`;
            verboseLog(`Depth Test Finished. Max N for ~${timeLimitMs}ms: ${maxNReached}`, "DepthTest");
            isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test";
        };
        
        window.runPerformanceTest = async () => {
            if (!await initializeWasm()) return;
            const funcToTest = document.getElementById('perfTestFunction').value;
            const nValue = parseInt(document.getElementById('perfTestNValue').value);
            let xValueStr = document.getElementById('perfTestXValue').value.trim(); 
            const iterations = parseInt(document.getElementById('perfTestIterations').value);

            if (isNaN(nValue) || isNaN(iterations) || iterations <= 0) {
                displayMain("Performance Test", "Invalid N value or iterations.", "error");
                verboseLog("Invalid N value or iterations for performance test.", "PerfTest"); return;
            }
            displayMain("Performance Test", `Running ${funcToTest} for N=${nValue}, ${iterations} iterations...`, "info");
            verboseLog(`Starting Performance Test: ${funcToTest}, N=${nValue}, Iterations=${iterations}`, "PerfTest");
            
            let totalTime = 0; let operationSuccess = 0; let operationError = 0;
            let sampleArg1, sampleArg2; 
            let seedOffsetForPerfTest = Date.now() % 1000; 

            try { 
                 if (funcToTest === "is_member" || funcToTest === "decompose_to_base" || funcToTest === "create_paired_entity") {
                    if (!xValueStr && (funcToTest === "is_member" || funcToTest === "decompose_to_base")) { 
                         verboseLog("PerfTest: No X value for is_member/decompose, generating random...", "PerfTest-Setup");
                         xValueStr = await generate_random_member_wasm(nValue, seedOffsetForPerfTest++); 
                         verboseLog(`PerfTest: Generated X = ${xValueStr.slice(0,20)}... for N=${nValue}`, "PerfTest-Setup");
                    } else if (!xValueStr && funcToTest === "create_paired_entity") { xValueStr = "0"; verboseLog(`PerfTest: No X value for create_paired_entity, using "0".`, "PerfTest-Setup");}
                    sampleArg1 = xValueStr; sampleArg2 = nValue;
                } else if (funcToTest === "compose_from_base") {
                    const numLevelsRecursion = Math.log2(nValue / currentNBaseForDisplay);
                    if (isNaN(numLevelsRecursion) || !Number.isInteger(numLevelsRecursion) || numLevelsRecursion < 0) { throw new Error(`Cannot determine base components for N=${nValue} from N_base=${currentNBaseForDisplay}`); }
                    const numBaseComponents = Math.pow(2, numLevelsRecursion);
                    const sBaseArray = currentSBaseForDisplay.split(',').map(s => s.trim());
                    if (sBaseArray.length === 0) { throw new Error(`S_Base is empty for compose test.`);}
                    let tempSampleArg1 = [];
                    for(let i=0; i<numBaseComponents; i++) tempSampleArg1.push(sBaseArray[i % sBaseArray.length]); 
                    sampleArg1 = tempSampleArg1; 
                } else if (funcToTest === "generate_random_member") { sampleArg1 = nValue; sampleArg2 = 0; } 
                else { throw new Error(`Unknown function for performance test: ${funcToTest}`);}
            } catch (e) { const errText = `Error preparing args for ${funcToTest}: ${e}`; displayMain("Performance Test", errText, "error"); verboseLog(errText, "PerfTest-Setup"); return;}

            const overallStartTime = performance.now();
            for (let i = 0; i < iterations; i++) {
                const iterStartTime = performance.now();
                try {
                    switch (funcToTest) {
                        case "is_member": is_member_wasm(sampleArg1, sampleArg2); break;
                        case "decompose_to_base": decompose_to_base_wasm(sampleArg1, sampleArg2); break;
                        case "compose_from_base": compose_from_base_wasm(sampleArg1); break; 
                        case "generate_random_member": generate_random_member_wasm(sampleArg1, i + seedOffsetForPerfTest); break; 
                        case "create_paired_entity": create_paired_entity_wasm(sampleArg1, sampleArg2); break;
                    }
                    operationSuccess++;
                } catch (e) { operationError++; if (i < 3 && iterations > 10) verboseLog(`PerfTest iter ${i} error: ${e}`, funcToTest); }
                const iterEndTime = performance.now(); totalTime += (iterEndTime - iterStartTime);
            }
            const overallEndTime = performance.now();
            const perfResults = { 
                action: `PerformanceTest[${funcToTest}]`,
                inputs: { N: nValue, X_val_used: (funcToTest !== "compose_from_base" && funcToTest !== "generate_random_member") ? String(sampleArg1).slice(0,20) + "..." : "N/A", iterations: iterations },
                total_js_loop_time_ms: (overallEndTime - overallStartTime).toFixed(3),
                total_wasm_calls_time_ms: totalTime.toFixed(3),
                avg_wasm_call_time_ms: (iterations > 0 ? totalTime / iterations : 0).toFixed(5),
                successes: operationSuccess, errors: operationError
            };
            displayMain("Performance Test", perfResults, false);
            verboseLog(perfResults, "PerfTest");
        };
        
        function mapSBaseComponentsToXY(sBaseComponentsStrs, nBaseBits, svgWidth, svgHeight) {
            const sBaseValues = evoPlotSettings.sBaseCache;
            if (sBaseValues.length === 0) return { x: svgWidth / 2, y: svgHeight / 2 };
            const minSBase = Math.min(...sBaseValues);
            const maxSBase = Math.max(...sBaseValues);
            const rangeSBase = (maxSBase - minSBase) || 1; 
            let xNorm = 0.5, yNorm = 0.5; 
            const sBaseComponents = sBaseComponentsStrs.map(s => parseInt(s.trim()));

            if (sBaseComponents.length === 4) { 
                const a = sBaseComponents[0], b = sBaseComponents[1], c = sBaseComponents[2], d = sBaseComponents[3];
                const aN = (a - minSBase) / rangeSBase; const bN = (b - minSBase) / rangeSBase;
                const cN = (c - minSBase) / rangeSBase; const dN = (d - minSBase) / rangeSBase;
                xNorm = (aN * 0.6 + cN * 0.4); yNorm = (bN * 0.6 + dN * 0.4);
            } else if (sBaseComponents.length === 2) { 
                const a = sBaseComponents[0], b = sBaseComponents[1];
                xNorm = (a - minSBase) / rangeSBase; yNorm = (b - minSBase) / rangeSBase;
            } else if (sBaseComponents.length > 0) { 
                let sumX = 0, sumY = 0, countX = 0, countY = 0;
                for(let i=0; i < sBaseComponents.length; i++) {
                    const valN = (sBaseComponents[i] - minSBase) / rangeSBase;
                    if (i % 2 === 0) { sumX += valN; countX++; } else { sumY += valN; countY++; }
                }
                xNorm = countX > 0 ? (sumX / countX) : 0.5; yNorm = countY > 0 ? (sumY / countY) : 0.5;
            }
            xNorm = Math.max(0, Math.min(1, xNorm)); yNorm = Math.max(0, Math.min(1, yNorm));
            const padding = 30;
            return { x: padding + xNorm * (svgWidth - 2 * padding), y: padding + yNorm * (svgHeight - 2 * padding) };
        }

        function updateEvolutionPlot() {
            if (!evoPlotSettings.isRunning || !wasmInitialized) return;
            try {
                const currentNLevel = evoPlotSettings.nLevel;
                const randomXStr = generate_random_member_wasm(currentNLevel, Date.now() % 1000 + evolutionPoints.length + Math.random()*100);
                const pe_obj = create_paired_entity_wasm(randomXStr, currentNLevel);
                const xValForPlotStr = pe_obj.x; const xPrimeValStr = pe_obj.x_prime;
                const wasmDecompArrayX = decompose_to_base_wasm(xValForPlotStr, currentNLevel);
                const sBaseComponentsX = Array.from(wasmDecompArrayX).map(jsValToString);
                const svgWidth = parseInt(evolutionSvgElement.getAttribute('width'));
                const svgHeight = parseInt(evolutionSvgElement.getAttribute('height'));
                const coordsX = mapSBaseComponentsToXY(sBaseComponentsX, evoPlotSettings.nBaseCache, svgWidth, svgHeight);
                const offsetAmount = Math.max(5 / evoZoomLevel, 10 / evoZoomLevel); 
                const angle = Math.random() * 2 * Math.PI; 
                const coordsXPrime = { x: coordsX.x + offsetAmount * Math.cos(angle), y: coordsX.y + offsetAmount * Math.sin(angle) };
                evolutionPoints.push({ 
                    x_coord: coordsX.x, y_coord: coordsX.y, xp_coord: coordsXPrime, age: 0, 
                    x_val_str: xValForPlotStr, xp_val_str: xPrimeValStr, s_base_X: sBaseComponentsX,
                });
                if (evolutionPoints.length > evoPlotSettings.maxPoints) evolutionPoints.shift(); 
                evoPlotMasterGroup.innerHTML = ''; 
                evolutionPoints.forEach((p, index) => {
                    p.age++;
                    const maxAgeEffect = Math.max(50, evoPlotSettings.maxPoints * 0.8); 
                    const relativeAge = Math.min(p.age / maxAgeEffect, 1.0); 
                    const opacity = 0.95 - (relativeAge * 0.75); 
                    let baseRadius = 4 * (1 - relativeAge * 0.6); baseRadius = Math.max(1.0, baseRadius);
                    const radius = Math.max(0.5 / evoZoomLevel, baseRadius / evoZoomLevel);
                    let baseStrokeWidth = (index === evolutionPoints.length - 1) ? 1.2 : 0.4;
                    const strokeWidth = Math.max(0.1 / evoZoomLevel, baseStrokeWidth / evoZoomLevel);
                    const line = document.createElementNS(SVG_NS, 'line');
                    line.setAttribute('x1', p.x_coord); line.setAttribute('y1', p.y_coord);
                    line.setAttribute('x2', p.xp_coord.x); line.setAttribute('y2', p.xp_coord.y);
                    const lineHue = (parseInt(p.x_val_str.slice(-2) || "0") * 13) % 360; 
                    line.setAttribute('stroke', `hsla(${lineHue}, 60%, 55%, ${opacity * 0.4})`); 
                    line.setAttribute('stroke-width', Math.max(0.1 / evoZoomLevel, 0.4 / evoZoomLevel));
                    evoPlotMasterGroup.appendChild(line);
                    const circleX = document.createElementNS(SVG_NS, 'circle');
                    circleX.setAttribute('cx', p.x_coord); circleX.setAttribute('cy', p.y_coord);
                    circleX.setAttribute('r', radius);
                    let hueSourceX = p.s_base_X.length > 0 ? parseInt(p.s_base_X[0]) : 0;
                    const hueX = (hueSourceX * 70 + 0) % 360; 
                    const saturationX = 90 - (relativeAge * 50); const lightnessX = 60 - (relativeAge * 30);
                    circleX.setAttribute('fill', `hsla(${hueX}, ${saturationX}%, ${lightnessX}%, ${opacity})`);
                    circleX.setAttribute('stroke', (index === evolutionPoints.length - 1) ? '#f0f0f0' : `hsla(${hueX}, ${saturationX-15}%, ${lightnessX-15}%, ${opacity*0.7})`);
                    circleX.setAttribute('stroke-width', strokeWidth);
                    evoPlotMasterGroup.appendChild(circleX);
                    const circleXPrime = document.createElementNS(SVG_NS, 'circle');
                    circleXPrime.setAttribute('cx', p.xp_coord.x); circleXPrime.setAttribute('cy', p.xp_coord.y);
                    circleXPrime.setAttribute('r', radius * 0.75); 
                    const hueXPrime = (hueX + 180) % 360; 
                    const saturationXP = 75 - (relativeAge * 45); const lightnessXP = 55 - (relativeAge * 25);
                    circleXPrime.setAttribute('fill', `hsla(${hueXPrime}, ${saturationXP}%, ${lightnessXP}%, ${opacity * 0.85})`);
                    circleXPrime.setAttribute('stroke', (index === evolutionPoints.length - 1) ? '#dddddd' : `hsla(${hueXPrime}, ${saturationXP-15}%, ${lightnessXP-15}%, ${opacity*0.65})`);
                    circleXPrime.setAttribute('stroke-width', strokeWidth * 0.75);
                    evoPlotMasterGroup.appendChild(circleXPrime);
                });
            } catch (e) { const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e); verboseLog(`Error during evolution step: ${errorStr}`, "EvolutionPlot");}
            if (evoPlotSettings.isRunning) evolutionAnimationId = setTimeout(updateEvolutionPlot, evoPlotSettings.currentSpeed);
        }
        
        window.toggleEvolutionPlot = async () => { 
             if (!await initializeWasm()) return;
            const playPauseButton = document.getElementById('playPauseEvoButton');
            const stepButton = document.getElementById('stepEvoButton');
            if (evoPlotSettings.isRunning) { 
                evoPlotSettings.isRunning = false;
                if (evolutionAnimationId) clearTimeout(evolutionAnimationId);
                playPauseButton.textContent = 'Play';
                stepButton.disabled = false;
                verboseLog("Evolution plot paused.", "EvolutionPlot");
                displayMain("Evolution Plot", "Paused.", "info");
            } else { 
                evoPlotSettings.nLevel = parseInt(document.getElementById('evoNLevel').value) || 12;
                evoPlotSettings.maxPoints = parseInt(document.getElementById('evoMaxPoints').value) || 100;
                evoPlotSettings.speed = parseInt(document.getElementById('evoSpeed').value) || 200;
                evoPlotSettings.currentSpeed = evoPlotSettings.speed / evoPlotSettings.speedMultiplier;
                const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
                const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
                if (currentSBaseForDisplay !== sBaseValuesStr || currentNBaseForDisplay !== nBaseBits) {
                    displayMain("Evolution Plot Info", "Propagator settings changed. Re-initializing for plot.", "info");
                    try { setup_propagator_wasm(sBaseValuesStr, nBaseBits); currentSBaseForDisplay = sBaseValuesStr; currentNBaseForDisplay = nBaseBits; } 
                    catch(e) { displayMain("Evolution Plot Error", "Could not set propagator.", "error"); return; }
                }
                evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                if (evoPlotSettings.sBaseCache.length === 0) { displayMain("Evolution Plot Error", "S_base values invalid.", "error"); return;}
                evoPlotSettings.isRunning = true;
                playPauseButton.textContent = 'Pause';
                stepButton.disabled = true;
                verboseLog(`Evolution plot started/resumed: N=${evoPlotSettings.nLevel}, MaxPts=${evoPlotSettings.maxPoints}, Speed=${evoPlotSettings.currentSpeed}ms`, "EvolutionPlot");
                displayMain("Evolution Plot", `Running for N=${evoPlotSettings.nLevel}...`, "info");
                updateEvolutionPlot();
            }
        };
        window.stepForwardEvolution = async () => {
            if (!await initializeWasm()) return;
            if (evoPlotSettings.isRunning) toggleEvolutionPlot(); 
            evoPlotSettings.nLevel = parseInt(document.getElementById('evoNLevel').value) || 12;
            evoPlotSettings.maxPoints = parseInt(document.getElementById('evoMaxPoints').value) || 100;
            const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
            const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
            if (currentSBaseForDisplay !== sBaseValuesStr || currentNBaseForDisplay !== nBaseBits) {
                 try { setup_propagator_wasm(sBaseValuesStr, nBaseBits); currentSBaseForDisplay = sBaseValuesStr; currentNBaseForDisplay = nBaseBits; } catch(e) { /* ... */ }
            }
            evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
            evoPlotSettings.nBaseCache = currentNBaseForDisplay;
            verboseLog("Stepping forward evolution plot.", "EvolutionPlot");
            updateEvolutionPlot(); 
         };
        window.increaseEvolutionSpeed = () => { 
            evoPlotSettings.speedMultiplier *= 2;
            if (evoPlotSettings.speedMultiplier > 16) evoPlotSettings.speedMultiplier = 16;
            evoPlotSettings.currentSpeed = Math.max(10, evoPlotSettings.speed / evoPlotSettings.speedMultiplier);
            displayMain("Evolution Plot", `Speed: ${evoPlotSettings.speedMultiplier}x (Interval: ${evoPlotSettings.currentSpeed.toFixed(0)}ms)`, "info");
            verboseLog(`Evolution speed increased to ${evoPlotSettings.speedMultiplier}x`, "EvolutionPlot");
        };
        window.decreaseEvolutionSpeed = () => { 
            evoPlotSettings.speedMultiplier /= 2;
            if (evoPlotSettings.speedMultiplier < 0.125) evoPlotSettings.speedMultiplier = 0.125; 
            evoPlotSettings.currentSpeed = evoPlotSettings.speed / evoPlotSettings.speedMultiplier;
            displayMain("Evolution Plot", `Speed: ${evoPlotSettings.speedMultiplier}x (Interval: ${evoPlotSettings.currentSpeed.toFixed(0)}ms)`, "info");
            verboseLog(`Evolution speed decreased to ${evoPlotSettings.speedMultiplier}x`, "EvolutionPlot");
        };
        window.clearEvolutionPlot = () => { 
            if (evoPlotSettings.isRunning) toggleEvolutionPlot(); 
            evolutionPoints = [];
            if(evoPlotMasterGroup) evoPlotMasterGroup.innerHTML = ''; 
            evoViewBox = { x: 0, y: 0, width: 600, height: 400 }; 
            evoZoomLevel = 1;
            applyEvoViewTransform();
            verboseLog("Evolution plot cleared and view reset.", "EvolutionPlot");
            displayMain("Evolution Plot", "Cleared and view reset.", "info");
            if(document.getElementById('playPauseEvoButton')) document.getElementById('playPauseEvoButton').textContent = 'Play';
            if(document.getElementById('stepEvoButton')) document.getElementById('stepEvoButton').disabled = false;
        };
        
        function jsValToString(jsVal) { 
            return (typeof jsVal === 'string') ? jsVal : (jsVal && typeof jsVal.as_string === 'function') ? jsVal.as_string() : String(jsVal);
        }
        function applyEvoViewTransform() { 
            if(evoPlotMasterGroup) evoPlotMasterGroup.setAttribute('transform', `translate(${evoViewBox.x}, ${evoViewBox.y}) scale(${evoZoomLevel})`);
        }

        if (evolutionSvgElement) { // Add event listeners only if SVG element exists
            evolutionSvgElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoomIntensity = 0.1;
                const svgRect = evolutionSvgElement.getBoundingClientRect();
                const mouseX = event.clientX - svgRect.left;
                const mouseY = event.clientY - svgRect.top;
                const pointXBeforeZoom = (mouseX - evoViewBox.x) / evoZoomLevel;
                const pointYBeforeZoom = (mouseY - evoViewBox.y) / evoZoomLevel;
                let newZoomLevel = evoZoomLevel;
                if (event.deltaY < 0) { newZoomLevel *= (1 + zoomIntensity); } 
                else { newZoomLevel *= (1 - zoomIntensity); }
                newZoomLevel = Math.max(0.05, Math.min(20, newZoomLevel)); 
                evoViewBox.x = mouseX - pointXBeforeZoom * newZoomLevel;
                evoViewBox.y = mouseY - pointYBeforeZoom * newZoomLevel;
                evoZoomLevel = newZoomLevel;
                applyEvoViewTransform();
            });
            evolutionSvgElement.addEventListener('mousedown', (event) => {
                if (event.button !== 0) return; 
                evoIsPanning = true;
                evoLastPanPosition = { x: event.clientX, y: event.clientY };
                evolutionSvgElement.style.cursor = 'grabbing';
            });
            evolutionSvgElement.addEventListener('mousemove', (event) => {
                if (!evoIsPanning) return;
                const dx = event.clientX - evoLastPanPosition.x;
                const dy = event.clientY - evoLastPanPosition.y;
                evoViewBox.x += dx; evoViewBox.y += dy;
                evoLastPanPosition = { x: event.clientX, y: event.clientY };
                applyEvoViewTransform();
            });
            evolutionSvgElement.addEventListener('mouseup', () => { 
                evoIsPanning = false; evolutionSvgElement.style.cursor = 'grab';
            });
            evolutionSvgElement.addEventListener('mouseleave', () => { 
                if (evoIsPanning) { evoIsPanning = false; evolutionSvgElement.style.cursor = 'grab';}
            });
        }

        window.toggleFullLog = () => { 
            fullOutputLog.style.display = (fullOutputLog.style.display === 'none' || fullOutputLog.style.display === '') ? 'block' : 'none';
            if (fullOutputLog.style.display === 'block') fullOutputLog.scrollTop = fullOutputLog.scrollHeight;
        };
        window.exportFullLog = () => {
             const blob = new Blob([fullOutputLog.value], { type: 'text/plain' }); const anchor = document.createElement('a');
             anchor.download = 'paired_binary_log.txt'; anchor.href = URL.createObjectURL(blob);
             anchor.click(); URL.revokeObjectURL(anchor.href);
         };
        window.clearFullLog = () => { fullOutputLog.value = ''; };

        document.addEventListener('DOMContentLoaded', initializeWasm);

    </script>
</body>
</html>
