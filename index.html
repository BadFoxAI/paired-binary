<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paired Binary Generative Lattice</title>
    <style>
        :root {
            --primary-color: #303f9f; /* Darker Indigo for base */
            --primary-light: #5c6bc0; /* Lighter Indigo for accents */
            --primary-darker: #1a237e;
            --accent-color: #00897b; /* Teal */
            --accent-dark: #00796b;
            --background-color: #eceff1; /* Blue Grey Lighten-5 */
            --surface-color: #ffffff;
            --text-color: #263238; /* Blue Grey Darken-3 */
            --muted-text-color: #546e7a; /* Blue Grey Lighten-1 */
            --border-color: #cfd8dc; /* Blue Grey Lighten-3 */
            --input-bg-color: #ffffff;
            --status-ok-bg: #e8f5e9; --status-ok-text: #2e7d32;
            --status-error-bg: #ffebee; --status-error-text: #c62828;
            --status-info-bg: #e1f5fe; --status-info-text: #0277bd;
            --evolution-svg-bg: #181a1f; /* Darker space */
        }
        body {
            font-family: "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0; padding: 20px; background-color: var(--background-color);
            color: var(--text-color); line-height: 1.6; display: flex; flex-direction: column; align-items: center;
        }
        .main-container {
            width: 100%; max-width: 1000px; background-color: var(--surface-color);
            padding: 20px 25px; border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,0.12);
            border: 1px solid var(--border-color);
        }
        h1, h2, h3 { color: var(--primary-darker); text-align: center; }
        h1 { font-size: 2.4em; margin-bottom: 20px; font-weight: 700; letter-spacing: -0.5px;}
        h2 { font-size: 1.8em; margin-top: 40px; margin-bottom: 20px; border-bottom: 2px solid var(--primary-color); padding-bottom: 12px; font-weight: 600;}
        h3 { margin-top: 30px; margin-bottom: 15px; text-align:left; font-size: 1.4em; color: var(--primary-dark); font-weight: 600;}

        .status-panel { text-align: center; margin-bottom: 25px; padding: 12px; border-radius: 6px; font-weight: 500; border: 1px solid transparent; }
        .status-ok { background-color: var(--status-ok-bg); color: var(--status-ok-text); border-color: var(--status-ok-text); }
        .status-error { background-color: var(--status-error-bg); color: var(--status-error-text); border-color: var(--status-error-text); }
        .status-info { background-color: var(--status-info-bg); color: var(--status-info-text); border-color: var(--status-info-text); }

        .primary-visualization, .key-benchmark, .advanced-section {
            padding: 25px; margin-bottom: 35px;
            border: 1px solid var(--border-color);
            border-radius: 12px; background-color: #fbfcff; 
            box-shadow: 0 3px 8px rgba(0,0,0,0.07);
        }
        .primary-visualization p, .key-benchmark p { text-align: center; margin-bottom: 20px; color: var(--muted-text-color); font-size: 1em;}
        
        #evolutionSvgContainer { 
            text-align: center; 
            overflow: hidden; 
            width: 100%; max-width:640px; height: 420px; 
            margin: 20px auto; 
            border: 1px solid var(--border-color); 
            cursor: grab; 
            position: relative; 
            background-color: var(--evolution-svg-bg); 
            border-radius: 8px;
        }
        #evolutionSvg { display: block; width:100%; height:100%;} 

        .evolution-controls { text-align:center; margin-bottom:15px; display:flex; flex-wrap:wrap; justify-content:center; align-items:center; gap:10px;}
        .evolution-controls label { margin-right: 5px; font-size:0.9em; color: var(--muted-text-color); }
        .evolution-controls input[type="number"] { width: 65px; padding: 8px; font-size:0.9em;}
        .evolution-controls button { width: auto; padding: 8px 12px; font-size:0.85em; margin: 2px;}
        
        button {
            background-color: var(--primary-color); color: white;
            padding: 12px 22px; border: none; border-radius: 5px;
            cursor: pointer; font-size: 1em; font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-block; margin: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover { background-color: var(--primary-dark); transform: translateY(-1px); }
        button:active { background-color: var(--primary-darker); transform: translateY(0px); }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; transform: translateY(0); opacity: 0.7; }
        button.secondary-action { background-color: #78909c; /* Blue Grey */ }
        button.secondary-action:hover { background-color: #607d8b; }
        button.test-suite-button { background-color: var(--accent-color); } /* Green Accent */
        button.test-suite-button:hover { background-color: var(--accent-dark); }


        details {
            background-color: #f8f9fa; border: 1px solid var(--border-color);
            border-radius: 6px; margin-top: 30px;
        }
        summary {
            font-weight: 600; font-size: 1.25em; color: var(--primary-dark);
            padding: 15px 20px; cursor: pointer; background-color: #eef2f7; 
            border-radius: 6px; transition: background-color 0.2s ease;
            list-style-position: inside; 
        }
        details[open] summary { border-bottom: 1px solid var(--border-color); border-radius: 6px 6px 0 0;}
        summary:hover { background-color: #d6e0f0; }
        .details-content { padding: 25px; background-color: var(--surface-color); border-radius: 0 0 6px 6px;}

        .control-group { margin-bottom: 18px; padding: 12px; border-radius: 5px; background-color: #fdfdff; border: 1px solid #f0f0f0;}
        .control-group label { display: block; margin-bottom: 6px; font-weight: 500; color: #495057; font-size: 0.95em; }
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group select { 
            width: calc(100% - 24px); padding: 10px; margin-bottom: 10px;
            border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; font-size: 1em;
            background-color: var(--input-bg-color);
        }
        .control-group input[type="text"]:focus,
        .control-group input[type="number"]:focus,
        .control-group select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(63, 81, 181, 0.25);
            outline: none;
        }
        .control-group button { width: auto; font-size: 0.95em; padding: 8px 18px; }

        #mainOutputArea, #benchmarkResultArea {
            margin-top: 18px; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px;
            background-color: #eef2f7; min-height: 45px; font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap; font-size: 0.95em; overflow-wrap: break-word;
        }
        #fullLogContainer { margin-top: 30px;}
        #fullOutputLog { display:none; width: 100%; height: 300px; font-family: 'Courier New', Courier, monospace; font-size: 0.85em; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; box-sizing: border-box; background-color: #f8f9fa; white-space: pre-wrap; overflow-y: auto; margin-top: 10px;}
        .log-controls { margin-bottom: 10px; text-align: center; }
        .log-controls button { margin: 5px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Paired Binary Generative Lattice</h1>
        <div id="wasmStatus" class="status-panel status-info">Loading WASM...</div>
        <div id="mainOutputArea"><p><i>Status and results of primary actions will appear here.</i></p></div>

        <section class="primary-visualization">
            <h2>Generative Evolution Plot</h2>
            <p>Visualizes randomly generated S<sub>N</sub> Paired Entities (X and X') appearing over time. Coordinates and pseudo-3D depth are directly derived from the numerical "axis contributions" of X's S_base components.
               (Propagator settings from "Advanced Controls" are used).</p>
            <div class="evolution-controls">
                <label for="evoNLevel">N-Level:</label>
                <input type="number" id="evoNLevel" value="12" min="6" step="3"> 
                <label for="evoMaxPoints">Max Points:</label>
                <input type="number" id="evoMaxPoints" value="150" min="10">
                <!-- Removed Coordinate Mapping Strategy Dropdown to simplify to direct mapping -->
                <br>
                <label for="evoSpeed">Speed (ms/dot):</label>
                <input type="number" id="evoSpeed" value="100" min="1">
                
                <button onclick="toggleEvolutionPlot()" id="playPauseEvoButton">Play</button>
                <button onclick="stepForwardEvolution()" id="stepEvoButton" title="Step Forward">▶︎|</button>
                <button onclick="increaseEvolutionSpeed()" id="ffEvoButton" title="Faster">FF »</button>
                <button onclick="decreaseEvolutionSpeed()" id="slowEvoButton" title="Slower">« Slow</button>
                <button onclick="clearEvolutionPlot()" class="secondary-action">Clear & Reset</button>
            </div>
            <div id="evolutionSvgContainer">
                <svg id="evolutionSvg" width="600" height="400" viewBox="0 0 600 400" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
                    <g id="evoPlotMasterGroup"></g>
                </svg>
            </div>
        </section>

        <section class="key-benchmark">
            <h2>Key Performance Metric</h2>
            <p>Test how large 'N' can be for `generate_random_member` + `is_member` using the <b>currently configured</b> S_base and N_base from Advanced Controls.</p>
            <label for="depthTestTimeLimit">Time Limit per N (ms):</label>
            <input type="number" id="depthTestTimeLimit" value="500" style="width:100px; display:inline-block; margin-right:10px;">
            <button onclick="runDepthTest()" id="depthTestButton">Run Max N Depth Test</button>
            <div id="benchmarkResultArea" style="margin-top:15px;"><p><i>Depth test results will appear here.</i></p></div>
        </section>

        <details id="advancedControlsDetails">
            <summary>Advanced Controls & Detailed Tests »</summary>
            <div class="details-content">
                <h2>Propagator Setup</h2>
                <div class="control-group">
                    <label for="sBaseValuesInput">S_base Values (comma-separated decimal strings):</label>
                    <input type="text" id="sBaseValuesInput" value="0,1,2">
                    <label for="nBaseBitsInput">N_base Bits:</label>
                    <input type="number" id="nBaseBitsInput" value="3" min="1">
                    <button onclick="setupWasmPropagator()">Initialize / Update Propagator</button>
                </div>

                <h2>Automated Basic Tests</h2>
                <div class="control-group">
                    <button class="test-suite-button" onclick="runAutomatedTests()">Run Basic Logic Test Suite</button>
                </div>
                
                <h2>Performance Tests (Manual)</h2>
                <div class="control-group">
                    <h3>Run Speed Test</h3>
                    <label for="perfTestFunction">Function to Test:</label>
                    <select id="perfTestFunction">
                        <option value="is_member">is_member</option>
                        <option value="decompose_to_base">decompose_to_base</option>
                        <option value="compose_from_base">compose_from_base</option>
                        <option value="generate_random_member">generate_random_member</option>
                        <option value="create_paired_entity">create_paired_entity</option>
                    </select>
                    <label for="perfTestNValue">Target N-bits:</label>
                    <input type="number" id="perfTestNValue" value="12">
                     <label for="perfTestXValue">X Value for test (if applicable):</label>
                    <input type="text" id="perfTestXValue" value="0">
                    <label for="perfTestIterations">Number of Iterations:</label>
                    <input type="number" id="perfTestIterations" value="1000">
                    <button onclick="runPerformanceTest()">Start Manual Perf Test</button>
                </div>

                <h2>Manual Function Tests</h2>
                <div class="control-group">
                    <h3>Create Paired Entity</h3>
                    <label for="peXValueInput">X Value (decimal string):</label>
                    <input type="text" id="peXValueInput" value="2">
                    <label for="peNBitsInput">N-bits:</label>
                    <input type="number" id="peNBitsInput" value="3" min="1">
                    <button onclick="runCreatePairedEntity()">Create Paired Entity</button>
                </div>
                <div class="control-group">
                    <h3>Test S_N Membership</h3>
                    <label for="memberXValueInput">X Value (decimal string):</label>
                    <input type="text" id="memberXValueInput" value="18">
                    <label for="memberNBitsInput">Target N-bits:</label>
                    <input type="number" id="memberNBitsInput" value="6" min="1">
                    <button onclick="runIsMember()">Test Membership</button>
                </div>
                <div class="control-group">
                     <h3>Decompose to S_base</h3>
                    <label for="decomposeXValueInput">X Value (decimal string):</label>
                    <input type="text" id="decomposeXValueInput" value="18">
                    <label for="decomposeNBitsInput">Target N-bits:</label>
                    <input type="number" id="decomposeNBitsInput" value="6" min="1">
                    <button onclick="runDecompose()">Decompose</button>
                </div>
                <div class="control-group">
                    <h3>Compose from S_base</h3>
                    <label for="composeComponentsInput">S_base Components (comma-separated decimal strings):</label>
                    <input type="text" id="composeComponentsInput" value="2,2">
                    <button onclick="runCompose()">Compose</button>
                </div>
                <div class="control-group">
                    <h3>Generate Random S_N Member</h3>
                    <label for="randomNBitsInput">Target N-bits:</label>
                    <input type="number" id="randomNBitsInput" value="6" min="1">
                    <label for="randomSeedOffsetInput">Seed Offset (for PRNG consistency):</label>
                    <input type="number" id="randomSeedOffsetInput" value="0">
                    <button onclick="runGenerateRandom()">Generate Random</button>
                </div>
            </div>
        </details>

        <div id="fullLogContainer">
            <h2>Verbose Log</h2>
            <div class="log-controls">
                <button onclick="toggleFullLog()" class="secondary-action">Toggle Full Log Display</button>
                <button onclick="exportFullLog()" class="secondary-action">Export Full Log</button>
                <button onclick="clearFullLog()" class="secondary-action">Clear Full Log</button>
            </div>
            <textarea id="fullOutputLog" readonly></textarea>
        </div>
    </div>

    <script type="module">
        // WASM function bindings (assigned in initializeWasm)
        let setup_propagator_wasm, is_member_wasm, decompose_to_base_wasm, compose_from_base_wasm,
            generate_random_member_wasm, create_paired_entity_wasm;

        import init, * as wasm_exports from './pkg/paired_binary.js';

        // DOM Elements
        const mainOutputArea = document.getElementById('mainOutputArea');
        const benchmarkResultArea = document.getElementById('benchmarkResultArea');
        const fullOutputLog = document.getElementById('fullOutputLog');
        const wasmStatusDiv = document.getElementById('wasmStatus');
        const evolutionSvgElement = document.getElementById('evolutionSvg');
        const evoPlotMasterGroup = document.getElementById('evoPlotMasterGroup');
        const SVG_NS = "http://www.w3.org/2000/svg";
        
        // Global State
        let wasmInitialized = false;
        let currentSBaseForDisplay = "0,1,2"; 
        let currentNBaseForDisplay = 3;
        let isBenchmarking = false; 
        
        let evolutionAnimationId = null;
        let evolutionPoints = []; 
        let evoPlotSettings = {
            nLevel: 12, maxPoints: 150, speed: 100, currentSpeed: 100, speedMultiplier: 1.0,
            sBaseCache: [0,1,2], nBaseCache: 3, isRunning: false,
        };
        let evoViewBox = { x: 0, y: 0, width: 600, height: 400 }; 
        let evoZoomLevel = 1.0;
        let evoIsPanning = false;
        let evoLastPanPosition = { x: 0, y: 0 };

        // --- Logging ---
        function displayMain(message, type = "info") {
            mainOutputArea.innerHTML = `<p class="status-panel status-${type}">${message}</p>`;
            if (type === "error") console.error("MainDisplay:", message);
            else console.log("MainDisplay:", message);
        }

        function verboseLog(message, context = "Generic") {
            console.log(`[${context}]`, message);
            const timestamp = new Date().toLocaleTimeString();
            const currentLogVal = fullOutputLog.value;
            const maxLogLength = 50000; 
            const entry = `${timestamp}: [${context}] ${typeof message === 'string' ? message : JSON.stringify(message, null, 2)}\n\n`;
            fullOutputLog.value = (currentLogVal + entry).slice(-maxLogLength);
            if (fullOutputLog.style.display !== 'none') {
                fullOutputLog.scrollTop = fullOutputLog.scrollHeight;
            }
        }
        
        // --- WASM Initialization and Setup ---
        async function initializeWasm() {
            if (wasmInitialized) return true;
            wasmStatusDiv.textContent = "Loading WASM...";
            wasmStatusDiv.className = "status-panel status-info";
            try {
                await init(); 
                setup_propagator_wasm = wasm_exports.setup_propagator;
                is_member_wasm = wasm_exports.is_member;
                decompose_to_base_wasm = wasm_exports.decompose_to_base;
                compose_from_base_wasm = wasm_exports.compose_from_base;
                generate_random_member_wasm = wasm_exports.generate_random_member;
                create_paired_entity_wasm = wasm_exports.create_paired_entity;

                wasmStatusDiv.textContent = "WASM Module Initialized Successfully.";
                wasmStatusDiv.className = "status-panel status-ok";
                verboseLog("WASM module initialized successfully.", "System");
                wasmInitialized = true;
                
                const sBaseInputInitial = document.getElementById('sBaseValuesInput');
                const nBaseInputInitial = document.getElementById('nBaseBitsInput');
                try { 
                    setup_propagator_wasm(sBaseInputInitial.value, parseInt(nBaseInputInitial.value)); 
                    currentSBaseForDisplay = sBaseInputInitial.value;
                    currentNBaseForDisplay = parseInt(nBaseInputInitial.value);
                    evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                    evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                    verboseLog(`Default propagator S_base=${currentSBaseForDisplay}, N_base=${currentNBaseForDisplay} initialized.`, "System");
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`Error setting up default propagator: ${errorStr}`, "System");
                    displayMain(`Error setting up default propagator: ${errorStr}`, "error");
                }

                const playPauseButton = document.getElementById('playPauseEvoButton');
                const stepButton = document.getElementById('stepEvoButton');
                
                if(playPauseButton) playPauseButton.textContent = 'Play';
                if(stepButton) stepButton.disabled = false;
                // The stopEvoButton was removed and merged into playPauseEvoButton functionality
                // document.getElementById('stopEvoButton').disabled = true; 
                
                if (evoPlotMasterGroup && evolutionSvgElement) {
                    applyEvoViewTransform(); 
                    evolutionSvgElement.style.cursor = 'grab';
                }
                return true;
            } catch (e) {
                wasmStatusDiv.textContent = "WASM Initialization Failed! Check console.";
                wasmStatusDiv.className = "status-panel status-error";
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                verboseLog(`WASM Initialization Failed: ${errorStr}`, "System");
                wasmInitialized = false;
                return false;
            }
        }
        
        window.setupWasmPropagator = async () => { 
            if (!await initializeWasm()) return;
            const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
            const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
            currentSBaseForDisplay = sBaseValuesStr; 
            currentNBaseForDisplay = nBaseBits;
            try {
                setup_propagator_wasm(sBaseValuesStr, nBaseBits);
                displayMain(`Propagator initialized/updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "ok");
                verboseLog(`Propagator user-updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "Setup");
                evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                evoPlotSettings.nBaseCache = currentNBaseForDisplay;
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`Setup Propagator Error: ${errorStr}`, "error");
                verboseLog(`Error setting up propagator: ${errorStr}`, "Setup");
            }
        };
        
        async function runWasmOpForDisplay(actionName, operationFunc, ...args) {
            if (!await initializeWasm()) {
                displayMain(`${actionName} Error: WASM not initialized.`, "error");
                return Promise.reject("WASM not ready"); // Return a rejected promise
            }
            displayMain(`${actionName}: Processing...`, "info");
            const startTime = performance.now();
            try {
                // Ensure operationFunc is indeed a function before calling
                if (typeof operationFunc !== 'function') {
                     throw new Error(`Operation ${actionName} is not a function.`);
                }
                const result = await operationFunc(...args); 
                const endTime = performance.now();
                const timedResult = { result: result, time_ms: (endTime - startTime).toFixed(3) };
                displayMain(`${actionName} Complete.`, "ok"); 
                verboseLog({action: actionName, inputs: args.map(arg => Array.isArray(arg) ? `[${arg.join(',')}]` : String(arg)), ...timedResult}, "ManualOp");
                return result; 
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`${actionName} Error: ${errorStr}`, "error");
                verboseLog(`Error in ${actionName}: ${errorStr}`, "ManualOp");
                throw e; 
            }
        }

        window.runCreatePairedEntity = () => { 
            const x = document.getElementById('peXValueInput').value;
            const n = parseInt(document.getElementById('peNBitsInput').value);
            runWasmOpForDisplay("CreatePairedEntity", create_paired_entity_wasm, x, n).catch(e => {}); // Catch to prevent unhandled promise rejection
        };
        window.runIsMember = () => { 
            const x = document.getElementById('memberXValueInput').value;
            const n = parseInt(document.getElementById('memberNBitsInput').value);
            runWasmOpForDisplay("IsMember", is_member_wasm, x, n).catch(e => {});
        };
        window.runDecompose = async () => { 
            const x = document.getElementById('decomposeXValueInput').value;
            const n = parseInt(document.getElementById('decomposeNBitsInput').value);
            try {
                await runWasmOpForDisplay("Decompose", async (val, bits) => {
                    const wasm_array = decompose_to_base_wasm(val, bits);
                    const nativeJsArray = Array.from(wasm_array);
                    return nativeJsArray.map(jsValToString);
                }, x, n);
            } catch(e) {}
        };
        window.runCompose = () => { 
            const compsStr = document.getElementById('composeComponentsInput').value;
            const compsArr = compsStr.split(',').map(s => s.trim()).filter(s => s.length > 0);
            runWasmOpForDisplay("Compose", compose_from_base_wasm, compsArr).catch(e => {});
        };
        window.runGenerateRandom = () => { 
            const n = parseInt(document.getElementById('randomNBitsInput').value);
            const seed = parseInt(document.getElementById('randomSeedOffsetInput').value);
            runWasmOpForDisplay("GenerateRandom", generate_random_member_wasm, n, seed).catch(e => {});
        };

        window.runAutomatedTests = async () => {
            if (!await initializeWasm()) return;
            displayMain("Automated Tests", "Running... Check verbose log for details.", "info");
            verboseLog("Starting Automated Basic Test Suite...", "TestRunner");
            try { setup_propagator_wasm("0,1,2", 3); } catch(e) { verboseLog("Failed to set S3={0,1,2} for tests", "TestRunner"); displayMain("Automated Tests Error: Could not set S3.", "error"); return;}

            const tests = [
                { name: "PE_N3_X2", func: () => create_paired_entity_wasm("2", 3), expect: (r) => r.x === "2" && r.x_prime === "5" && r.n_bits === 3 },
                { name: "IsMember_S6_18_True", func: () => is_member_wasm("18", 6), expect: (r) => r === true },
                { name: "Decompose_S6_18", func: () => decompose_to_base_wasm("18", 6), expect: (r_arr) => Array.from(r_arr).map(jsValToString).join(',') === "2,2" },
                { name: "Compose_S6_From_[2,2]", func: () => compose_from_base_wasm(["2","2"]), expect: (r) => r.value === "18" && r.n_bits === 6 },
                { name: "GenRandom_S6_Valid", func: async () => { const r_str = await generate_random_member_wasm(6, 10); return {randomVal: r_str, isMember: await is_member_wasm(r_str, 6)}; }, expect: (res) => res.isMember === true && !isNaN(parseInt(res.randomVal)) },
            ];
            let testsPassed = 0; let testsFailed = 0;
            const suiteStartTime = performance.now();
            for (const test of tests) {
                verboseLog(`Running test: ${test.name}`, "TestRunner");
                let result, errorOccurred = false, actualError = null;
                try { result = await test.func(); } 
                catch (e) { errorOccurred = true; actualError = e; }

                if (test.expectError) {
                    if (errorOccurred) { verboseLog(`PASS: ${test.name}`, "TestRunner"); testsPassed++; } 
                    else { verboseLog(`FAIL: ${test.name} - Expected error, got success: ${JSON.stringify(result)}`, "TestRunner"); testsFailed++; }
                } else {
                    if (errorOccurred) { verboseLog(`FAIL: ${test.name} - Expected success, got error: ${String(actualError)}`, "TestRunner"); testsFailed++; } 
                    else {
                        let assertionPassed = false; 
                        try { assertionPassed = test.expect(result); } 
                        catch (ae) { verboseLog(`FAIL: ${test.name} - Assertion func error: ${ae}`, "TestRunner");}
                        if (assertionPassed) { verboseLog(`PASS: ${test.name}`, "TestRunner"); testsPassed++; } 
                        else { verboseLog(`FAIL: ${test.name} - Assertion failed. Got: ${JSON.stringify(result)}`, "TestRunner"); testsFailed++; }
                    }
                }
            }
            const suiteEndTime = performance.now();
            const totalSuiteTime = (suiteEndTime - suiteStartTime).toFixed(3);
            const summary = `Test Suite: ${testsPassed} passed, ${testsFailed} failed in ${totalSuiteTime} ms.`;
            displayMain("Automated Tests", summary + (testsFailed > 0 ? " Check verbose log for details." : " All OK!"), testsFailed > 0 ? "error" : "ok");
            verboseLog(summary, "TestRunner");
        };
        
        window.runDepthTest = async () => {
            if (!await initializeWasm()) return;
            if (isBenchmarking) { displayMain("Depth Test", "Benchmark already in progress.", "info"); return; }
            isBenchmarking = true;
            const depthTestButton = document.getElementById("depthTestButton");
            depthTestButton.disabled = true; depthTestButton.textContent = "Running Depth Test...";
            benchmarkResultArea.innerHTML = "<p><i>Running depth test... This may take some time. Please wait.</i></p>";
            verboseLog("Starting Max N Depth Test using current propagator settings...", "DepthTest");

            const sBaseForTest = document.getElementById('sBaseValuesInput').value; 
            const nBaseForTest = parseInt(document.getElementById('nBaseBitsInput').value);
            
            try { 
                setup_propagator_wasm(sBaseForTest, nBaseForTest); 
                currentSBaseForDisplay = sBaseForTest; 
                currentNBaseForDisplay = nBaseForTest;
                evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                verboseLog(`DepthTest using S_base='${sBaseForTest}', N_base=${nBaseForTest}`, "DepthTest-Setup");
            } catch(e) { 
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                benchmarkResultArea.innerHTML = `<p class="status-panel status-error">Error setting up propagator for test: ${errorStr}</p>`; 
                isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test"; return;
            }
            if (evoPlotSettings.sBaseCache.length === 0 || currentNBaseForDisplay === 0) {
                benchmarkResultArea.innerHTML = `<p class="status-panel status-error">Invalid S_base or N_base for depth test.</p>`;
                isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test"; return;
            }

            const timeLimitMs = parseInt(document.getElementById('depthTestTimeLimit').value) || 500;
            let currentN = nBaseForTest > 0 ? nBaseForTest * 2 : 6; 
            if (nBaseForTest > 0 && currentN < nBaseForTest ) currentN = nBaseForTest; 


            let maxNReached = 0; let results = [];
            const practicalBrowserNLimit = 8192; 

            while (currentN <= practicalBrowserNLimit && currentN >= nBaseForTest) {
                let isValidLevelForTest = false;
                if (currentN === nBaseForTest) {
                    isValidLevelForTest = true;
                } else if (currentN > nBaseForTest && nBaseForTest > 0 && currentN % nBaseForTest === 0) {
                    const factor = currentN / nBaseForTest;
                    isValidLevelForTest = (factor > 0) && ((factor & (factor - 1)) === 0); // Check if factor is power of 2
                }

                if (!isValidLevelForTest) {
                     verboseLog(`DepthTest: N=${currentN} is not valid for N_base=${nBaseForTest}. Finding next valid level.`, "DepthTest");
                     let tempFactor = Math.ceil(currentN / nBaseForTest);
                     let powerOf2 = 1;
                     while(powerOf2 < tempFactor) powerOf2 *= 2;
                     if (powerOf2 === 0 && tempFactor > 0) powerOf2 = tempFactor; // Should not happen with ceil
                     else if (powerOf2 === 0 && tempFactor === 0) powerOf2 = 1; // N_base is likely 0, start from 1*N_base for next
                     
                     currentN = nBaseForTest * powerOf2;
                     if (currentN <= results[results.length-1]?.N || currentN > practicalBrowserNLimit) { // Avoid infinite loop or going too far
                        verboseLog("Could not find next valid N level or exceeded limit. Stopping depth test.", "DepthTest");
                        break;
                     }
                     verboseLog(`Advancing to N=${currentN}`, "DepthTest");
                     continue; 
                }
                
                verboseLog(`DepthTest: Testing N=${currentN}`, "DepthTest");
                let xValStr; let duration = 0; let isMem = false; let testPassedThisN = false;
                try {
                    const stepStartTime = performance.now();
                    xValStr = await generate_random_member_wasm(currentN, Date.now() % 1000 + currentN); 
                    if (typeof xValStr !== 'string' || xValStr.length === 0) throw new Error("generate_random_member_wasm invalid output.");
                    isMem = await is_member_wasm(xValStr, currentN);
                    const stepEndTime = performance.now();
                    duration = stepEndTime - stepStartTime;
                    const xPreview = xValStr.length > 25 ? xValStr.slice(0, 25) + "..." : xValStr;
                    results.push({ N: currentN, time_ms: duration.toFixed(3), is_member_result: isMem, generated_x_preview: xPreview });
                    if (duration <= timeLimitMs) { maxNReached = currentN; testPassedThisN = true; } 
                    else { verboseLog(`DepthTest: N=${currentN} exceeded time limit (${duration.toFixed(2)}ms > ${timeLimitMs}ms). Stopping.`, "DepthTest"); break; }
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`DepthTest: Error at N=${currentN}: ${errorStr}`, "DepthTest");
                    results.push({ N: currentN, time_ms: duration.toFixed(3), error: errorStr, generated_x_preview: "ERROR_DURING_GEN/TEST" });
                    maxNReached = currentN > nBaseForTest ? currentN / 2 : 0; 
                    verboseLog(`DepthTest: Stopping due to error at N=${currentN}. Last N for gen: ${maxNReached}.`, "DepthTest");
                    break; 
                }
                if (!testPassedThisN) break; 
                
                if (currentN >= practicalBrowserNLimit / 2 && currentN < practicalBrowserNLimit && currentN > 0) { 
                    if (currentN * 2 > practicalBrowserNLimit) break; 
                } else if (currentN === 0 && nBaseForTest > 0) break;

                let nextN = currentN * 2;
                if (nextN <= currentN || (nextN === 0 && currentN > 0) ) break; 
                currentN = nextN; 
            }
            benchmarkResultArea.innerHTML = `<h3>Depth Test Results (S_base='${sBaseForTest}', N_base=${nBaseForTest}):</h3> <p>Max N reached for (generate_random + is_member) within ~${timeLimitMs}ms per N: <b>${maxNReached || 'None (or error at first level)'}</b></p> <pre>${JSON.stringify(results, null, 2)}</pre>`;
            verboseLog(`Depth Test Finished. Max N for ~${timeLimitMs}ms: ${maxNReached}`, "DepthTest");
            isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test";
        };
        
        window.runPerformanceTest = async () => {
             if (!await initializeWasm()) return;
            const funcToTest = document.getElementById('perfTestFunction').value;
            const nValue = parseInt(document.getElementById('perfTestNValue').value);
            let xValueStr = document.getElementById('perfTestXValue').value.trim(); 
            const iterations = parseInt(document.getElementById('perfTestIterations').value);

            if (isNaN(nValue) || isNaN(iterations) || iterations <= 0) {
                displayMain("Performance Test", "Invalid N value or iterations.", "error");
                verboseLog("Invalid N value or iterations for performance test.", "PerfTest"); return;
            }
            displayMain("Performance Test", `Running ${funcToTest} for N=${nValue}, ${iterations} iterations...`, "info");
            verboseLog(`Starting Performance Test: ${funcToTest}, N=${nValue}, Iterations=${iterations}`, "PerfTest");
            
            let totalTime = 0; let operationSuccess = 0; let operationError = 0;
            let sampleArg1, sampleArg2; 
            let seedOffsetForPerfTest = Date.now() % 1000; 

            try { 
                 if (funcToTest === "is_member" || funcToTest === "decompose_to_base" || funcToTest === "create_paired_entity") {
                    if (!xValueStr && (funcToTest === "is_member" || funcToTest === "decompose_to_base")) { 
                         verboseLog("PerfTest: No X value for is_member/decompose, generating random...", "PerfTest-Setup");
                         xValueStr = await generate_random_member_wasm(nValue, seedOffsetForPerfTest++); 
                         verboseLog(`PerfTest: Generated X = ${xValueStr.slice(0,20)}... for N=${nValue}`, "PerfTest-Setup");
                    } else if (!xValueStr && funcToTest === "create_paired_entity") { xValueStr = "0"; verboseLog(`PerfTest: No X value for create_paired_entity, using "0".`, "PerfTest-Setup");}
                    sampleArg1 = xValueStr; sampleArg2 = nValue;
                } else if (funcToTest === "compose_from_base") {
                    if (currentNBaseForDisplay === 0) throw new Error("N_base for current propagator is 0, cannot compose.");
                    const numLevelsRecursion = Math.log2(nValue / currentNBaseForDisplay);
                    if (isNaN(numLevelsRecursion) || !Number.isInteger(numLevelsRecursion) || numLevelsRecursion < 0) { throw new Error(`Cannot determine base components for N=${nValue} from N_base=${currentNBaseForDisplay}`); }
                    const numBaseComponents = Math.pow(2, numLevelsRecursion);
                    const sBaseArray = currentSBaseForDisplay.split(',').map(s => s.trim());
                    if (sBaseArray.length === 0) { throw new Error(`S_Base is empty for compose test.`);}
                    let tempSampleArg1 = [];
                    for(let i=0; i<numBaseComponents; i++) tempSampleArg1.push(sBaseArray[i % sBaseArray.length]); 
                    sampleArg1 = tempSampleArg1; 
                } else if (funcToTest === "generate_random_member") { sampleArg1 = nValue; sampleArg2 = 0; } 
                else { throw new Error(`Unknown function for performance test: ${funcToTest}`);}
            } catch (e) { const errText = `Error preparing args for ${funcToTest}: ${e}`; displayMain("Performance Test", errText, "error"); verboseLog(errText, "PerfTest-Setup"); return;}

            const overallStartTime = performance.now();
            for (let i = 0; i < iterations; i++) {
                const iterStartTime = performance.now();
                try {
                    switch (funcToTest) {
                        case "is_member": is_member_wasm(sampleArg1, sampleArg2); break;
                        case "decompose_to_base": decompose_to_base_wasm(sampleArg1, sampleArg2); break;
                        case "compose_from_base": compose_from_base_wasm(sampleArg1); break; 
                        case "generate_random_member": generate_random_member_wasm(sampleArg1, i + seedOffsetForPerfTest); break; 
                        case "create_paired_entity": create_paired_entity_wasm(sampleArg1, sampleArg2); break;
                    }
                    operationSuccess++;
                } catch (e) { operationError++; if (i < 3 && iterations > 10) verboseLog(`PerfTest iter ${i} error: ${e}`, funcToTest); }
                const iterEndTime = performance.now(); totalTime += (iterEndTime - iterStartTime);
            }
            const overallEndTime = performance.now();
            const perfResults = { 
                action: `PerformanceTest[${funcToTest}]`,
                inputs: { N: nValue, X_val_used: (funcToTest !== "compose_from_base" && funcToTest !== "generate_random_member") ? String(sampleArg1).slice(0,20) + "..." : "N/A", iterations: iterations },
                total_js_loop_time_ms: (overallEndTime - overallStartTime).toFixed(3),
                total_wasm_calls_time_ms: totalTime.toFixed(3),
                avg_wasm_call_time_ms: (iterations > 0 ? totalTime / iterations : 0).toFixed(5),
                successes: operationSuccess, errors: operationError
            };
            displayMain("Performance Test", perfResults, false);
            verboseLog(perfResults, "PerfTest");
        };
        
        // --- REVISED: Generative Evolution Plot with Direct Coordinate Mapping ---
        function mapSBaseToCoordinates(sBaseComponentsStrs, svgWidth, svgHeight) {
            const sBaseNumbers = sBaseComponentsStrs.map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            if (sBaseNumbers.length === 0) return { x: svgWidth / 2, y: svgHeight / 2, z_factor: 0.5 };

            const sBaseCacheNumbers = evoPlotSettings.sBaseCache;
            const minSB = sBaseCacheNumbers.length > 0 ? Math.min(...sBaseCacheNumbers) : 0;
            const maxSB = sBaseCacheNumbers.length > 0 ? Math.max(...sBaseCacheNumbers) : (sBaseCacheNumbers.length > 0 ? sBaseCacheNumbers[0] : 1);
            const rangeSB = (maxSB - minSB) || 1;

            let x = 0, y = 0, zSum = 0;
            const numComps = sBaseNumbers.length;
            const normComps = sBaseNumbers.map(c => (c - minSB) / rangeSB);

            if (numComps === 1) {
                x = normComps[0]; y = 0.5; zSum = normComps[0];
            } else if (numComps === 2) { 
                x = normComps[0]; y = normComps[1]; zSum = normComps[0] + normComps[1];
            } else if (numComps >= 4) { 
                x = (normComps[0] - 0.5) + (normComps[2] - 0.5); 
                y = (normComps[1] - 0.5) + (normComps[3] - 0.5);
                normComps.forEach(nc => zSum += nc);
                if (numComps >=6) { x += (normComps[4] - 0.5) * 0.5; y += (normComps[5] - 0.5) * 0.5; }
            } else if (numComps === 3) { 
                x = (normComps[0] - 0.5); y = (normComps[1] - 0.5);
                zSum = normComps[0] + normComps[1] + normComps[2]; 
            } else { // Should be numComps > 0 due to earlier check
                 for (let i = 0; i < numComps; i++) {
                    zSum += normComps[i];
                    if (i % 2 === 0) x += (normComps[i] - 0.5); else y += (normComps[i] - 0.5);
                }
            }
            
            const maxPossibleSumOfCenteredComps = Math.ceil(numComps/2) * 0.5; // Max sum if all were max_norm-0.5 or min_norm-0.5
            const xFinalNorm = numComps > 0 ? (x / (maxPossibleSumOfCenteredComps || 1) + 1) / 2 : 0.5;
            const yFinalNorm = numComps > 0 ? (y / (maxPossibleSumOfCenteredComps || 1) + 1) / 2 : 0.5;

            const padding = 40;
            return {
                x: padding + (Math.max(0, Math.min(1, xFinalNorm || 0.5))) * (svgWidth - 2 * padding),
                y: padding + (Math.max(0, Math.min(1, yFinalNorm || 0.5))) * (svgHeight - 2 * padding),
                z_factor: 0.3 + (1.0 - Math.max(0, Math.min(1, (numComps > 0 ? zSum / numComps : 0.5) ) ) ) * 0.7 
            };
        }

        function updateEvolutionPlot() {
            if (!evoPlotSettings.isRunning || !wasmInitialized) return;
            try {
                const currentNLevel = evoPlotSettings.nLevel;
                const randomXStr = generate_random_member_wasm(currentNLevel, Date.now() % 10000 + evolutionPoints.length + Math.floor(Math.random()*1000));
                const pe_obj = create_paired_entity_wasm(randomXStr, currentNLevel);
                const xValForPlotStr = pe_obj.x; 
                const xPrimeValStr = pe_obj.x_prime;
                const wasmDecompArrayX = decompose_to_base_wasm(xValForPlotStr, currentNLevel);
                const sBaseComponentsX = Array.from(wasmDecompArrayX).map(jsValToString);

                const svgWidth = parseInt(evolutionSvgElement.getAttribute('width'));
                const svgHeight = parseInt(evolutionSvgElement.getAttribute('height'));
                
                const positionDataX = mapSBaseToCoordinates(sBaseComponentsX, svgWidth, svgHeight);

                const offsetMagnitude = Math.max(3 / evoZoomLevel, 6 / evoZoomLevel) * positionDataX.z_factor; 
                const angle = (evolutionPoints.length * 1.618) % (2 * Math.PI); 
                const coordsXPrime = { 
                    x: positionDataX.x + offsetMagnitude * Math.cos(angle), 
                    y: positionDataX.y + offsetMagnitude * Math.sin(angle),
                };
                
                evolutionPoints.push({ 
                    x_coord: positionDataX.x, y_coord: positionDataX.y, z_factor: positionDataX.z_factor,
                    xp_coord: coordsXPrime, age: 0, 
                    x_val_str: xValForPlotStr, xp_val_str: xPrimeValStr, s_base_X: sBaseComponentsX,
                });
                if (evolutionPoints.length > evoPlotSettings.maxPoints) evolutionPoints.shift(); 

                evoPlotMasterGroup.innerHTML = ''; 
                const sortedPoints = [...evolutionPoints].sort((a,b) => (a.z_factor || 0.5) - (b.z_factor || 0.5));

                sortedPoints.forEach((p, indexInSorted) => {
                    p.age++;
                    const isNewestOriginal = evolutionPoints.findIndex(ep => ep.x_val_str === p.x_val_str && ep.xp_val_str === p.xp_val_str) === evolutionPoints.length - 1;
                    const maxAgeEffect = Math.max(25, evoPlotSettings.maxPoints * 0.6); 
                    const relativeAge = Math.min(p.age / maxAgeEffect, 1.0); 
                    const baseOpacity = 1.0 - (relativeAge * 0.90); 
                    
                    const finalOpacity = baseOpacity * (0.2 + p.z_factor * 0.8);

                    let baseRadius = 3.0 * (1 - relativeAge * 0.4); 
                    baseRadius = Math.max(0.7, baseRadius);
                    const radius = Math.max(0.2 / evoZoomLevel, (baseRadius * p.z_factor) / evoZoomLevel);

                    let baseStrokeWidth = isNewestOriginal ? 0.8 : 0.2;
                    const strokeWidth = Math.max(0.05 / evoZoomLevel, baseStrokeWidth / evoZoomLevel);

                    const line = document.createElementNS(SVG_NS, 'line');
                    line.setAttribute('x1', p.x_coord); line.setAttribute('y1', p.y_coord);
                    line.setAttribute('x2', p.xp_coord.x); line.setAttribute('y2', p.xp_coord.y);
                    const lineHue = (parseInt(p.x_val_str.slice(-3) || "0", 16) * 0.2) % 360; 
                    const lineOpacity = Math.min(finalOpacity, (p.xp_coord.z_factor ? finalOpacity * (0.2 + p.xp_coord.z_factor*0.8) : finalOpacity) ) * 0.25; 
                    line.setAttribute('stroke', `hsla(${lineHue}, 50%, 70%, ${lineOpacity})`); 
                    line.setAttribute('stroke-width', Math.max(0.05 / evoZoomLevel, 0.25 / evoZoomLevel));
                    evoPlotMasterGroup.appendChild(line);

                    const circleX = document.createElementNS(SVG_NS, 'circle');
                    circleX.setAttribute('cx', p.x_coord); circleX.setAttribute('cy', p.y_coord);
                    circleX.setAttribute('r', radius);
                    let hueSourceX = p.s_base_X.length > 0 ? parseInt(p.s_base_X[p.s_base_X.length - 1]) : 0; 
                    const hueX = (hueSourceX * 60 + p.z_factor * 90) % 360; 
                    const saturationX = 85 - (relativeAge * 20); 
                    const lightnessX = 50 + (p.z_factor * 20) - (relativeAge * 15);
                    circleX.setAttribute('fill', `hsla(${hueX}, ${saturationX}%, ${lightnessX}%, ${finalOpacity})`);
                    circleX.setAttribute('stroke', isNewestOriginal ? '#fff' : `hsla(${hueX}, ${saturationX}%, ${lightnessX - 10}%, ${finalOpacity*0.8})`);
                    circleX.setAttribute('stroke-width', strokeWidth);
                    evoPlotMasterGroup.appendChild(circleX);

                    const circleXPrime = document.createElementNS(SVG_NS, 'circle');
                    circleXPrime.setAttribute('cx', p.xp_coord.x); circleXPrime.setAttribute('cy', p.xp_coord.y);
                    circleXPrime.setAttribute('r', radius); 
                    const hueXPrime = (hueX + 180) % 360; 
                    circleXPrime.setAttribute('fill', 'none'); 
                    circleXPrime.setAttribute('stroke', `hsla(${hueXPrime}, 80%, 70%, ${finalOpacity * 0.85})`);
                    circleXPrime.setAttribute('stroke-width', strokeWidth * 1.1); 
                    evoPlotMasterGroup.appendChild(circleXPrime);
                });
            } catch (e) { const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e); verboseLog(`Error during evolution step: ${errorStr}`, "EvolutionPlot");}
            if (evoPlotSettings.isRunning) evolutionAnimationId = setTimeout(updateEvolutionPlot, evoPlotSettings.currentSpeed);
        }
        
        window.toggleEvolutionPlot = async () => { 
             if (!await initializeWasm()) return;
            const playPauseButton = document.getElementById('playPauseEvoButton');
            const stepButton = document.getElementById('stepEvoButton');
            if (evoPlotSettings.isRunning) { 
                evoPlotSettings.isRunning = false;
                if (evolutionAnimationId) clearTimeout(evolutionAnimationId);
                playPauseButton.textContent = 'Play';
                stepButton.disabled = false;
                verboseLog("Evolution plot paused.", "EvolutionPlot");
                displayMain("Evolution Plot", "Paused.", "info");
            } else { 
                evoPlotSettings.nLevel = parseInt(document.getElementById('evoNLevel').value) || 12;
                evoPlotSettings.maxPoints = parseInt(document.getElementById('evoMaxPoints').value) || 150;
                evoPlotSettings.speed = parseInt(document.getElementById('evoSpeed').value) || 100;
                // evoPlotSettings.coordMapStrategy removed as a setting
                evoPlotSettings.currentSpeed = Math.max(1, Math.round(evoPlotSettings.speed / evoPlotSettings.speedMultiplier));

                const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
                const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
                if (currentSBaseForDisplay !== sBaseValuesStr || currentNBaseForDisplay !== nBaseBits) {
                    displayMain("Evolution Plot Info", "Propagator settings changed. Re-initializing for plot.", "info");
                    try { 
                        setup_propagator_wasm(sBaseValuesStr, nBaseBits); 
                        currentSBaseForDisplay = sBaseValuesStr; currentNBaseForDisplay = nBaseBits; 
                        evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                        evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                    } 
                    catch(e) { displayMain("Evolution Plot Error", "Could not set propagator.", "error"); return; }
                } else {
                     evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                     evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                }
                if (evoPlotSettings.sBaseCache.length === 0) { displayMain("Evolution Plot Error", "S_base values invalid.", "error"); return;}

                evoPlotSettings.isRunning = true;
                playPauseButton.textContent = 'Pause';
                stepButton.disabled = true;
                verboseLog(`Evolution plot started/resumed: N=${evoPlotSettings.nLevel}, MaxPts=${evoPlotSettings.maxPoints}, Speed=${evoPlotSettings.currentSpeed}ms`, "EvolutionPlot");
                displayMain("Evolution Plot", `Running for N=${evoPlotSettings.nLevel}...`, "info");
                updateEvolutionPlot();
            }
        };
        window.stepForwardEvolution = async () => {
            if (!await initializeWasm()) return;
            if (evoPlotSettings.isRunning) toggleEvolutionPlot(); 
            evoPlotSettings.nLevel = parseInt(document.getElementById('evoNLevel').value) || 12;
            evoPlotSettings.maxPoints = parseInt(document.getElementById('evoMaxPoints').value) || 150;
            // evoPlotSettings.coordMapStrategy removed
            const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
            const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
            if (currentSBaseForDisplay !== sBaseValuesStr || currentNBaseForDisplay !== nBaseBits) {
                 try { 
                    setup_propagator_wasm(sBaseValuesStr, nBaseBits); 
                    currentSBaseForDisplay = sBaseValuesStr; currentNBaseForDisplay = nBaseBits; 
                    evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                    evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                } catch(e) { displayMain("Evolution Plot Error: Could not set propagator for step.", "error"); return; }
            } else {
                 evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                 evoPlotSettings.nBaseCache = currentNBaseForDisplay;
            }
            if (evoPlotSettings.sBaseCache.length === 0) { displayMain("Evolution Plot Error", "S_base values invalid for step.", "error"); return;}
            verboseLog("Stepping forward evolution plot.", "EvolutionPlot");
            updateEvolutionPlot(); 
         };
        window.increaseEvolutionSpeed = () => { 
            evoPlotSettings.speedMultiplier *= 1.5; 
            evoPlotSettings.currentSpeed = Math.max(1, Math.round(evoPlotSettings.speed / evoPlotSettings.speedMultiplier)); 
            displayMain("Evolution Plot", `Speed: ${evoPlotSettings.speedMultiplier.toFixed(2)}x (Interval: ${evoPlotSettings.currentSpeed}ms)`, "info");
            verboseLog(`Evolution speed increased to ${evoPlotSettings.speedMultiplier.toFixed(2)}x`, "EvolutionPlot");
            if(evoPlotSettings.isRunning) { 
                clearTimeout(evolutionAnimationId);
                evolutionAnimationId = setTimeout(updateEvolutionPlot, evoPlotSettings.currentSpeed);
            }
        };
        window.decreaseEvolutionSpeed = () => { 
            evoPlotSettings.speedMultiplier /= 1.5;
            if (evoPlotSettings.speedMultiplier < (1/32)) evoPlotSettings.speedMultiplier = (1/32); 
            evoPlotSettings.currentSpeed = Math.round(evoPlotSettings.speed / evoPlotSettings.speedMultiplier);
            displayMain("Evolution Plot", `Speed: ${evoPlotSettings.speedMultiplier.toFixed(2)}x (Interval: ${evoPlotSettings.currentSpeed}ms)`, "info");
            verboseLog(`Evolution speed decreased to ${evoPlotSettings.speedMultiplier.toFixed(2)}x`, "EvolutionPlot");
             if(evoPlotSettings.isRunning) {
                clearTimeout(evolutionAnimationId);
                evolutionAnimationId = setTimeout(updateEvolutionPlot, evoPlotSettings.currentSpeed);
            }
        };
        window.clearEvolutionPlot = () => { 
            if (evoPlotSettings.isRunning) toggleEvolutionPlot(); 
            evolutionPoints = [];
            if(evoPlotMasterGroup) evoPlotMasterGroup.innerHTML = ''; 
            evoViewBox = { x: 0, y: 0, width: 600, height: 400 }; 
            evoZoomLevel = 1;
            applyEvoViewTransform();
            verboseLog("Evolution plot cleared and view reset.", "EvolutionPlot");
            displayMain("Evolution Plot", "Cleared and view reset.", "info");
            const playPauseButton = document.getElementById('playPauseEvoButton');
            if(playPauseButton) playPauseButton.textContent = 'Play';
            const stepButton = document.getElementById('stepEvoButton');
            if(stepButton) stepButton.disabled = false;
        };
        
        function jsValToString(jsVal) { 
            return (typeof jsVal === 'string') ? jsVal : (jsVal && typeof jsVal.as_string === 'function') ? jsVal.as_string() : String(jsVal);
        }
        function applyEvoViewTransform() { 
            if(evoPlotMasterGroup) evoPlotMasterGroup.setAttribute('transform', `translate(${evoViewBox.x}, ${evoViewBox.y}) scale(${evoZoomLevel})`);
        }

        if (evolutionSvgElement) {
            evolutionSvgElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoomIntensity = 0.1;
                const svgRect = evolutionSvgElement.getBoundingClientRect();
                const mouseX = event.clientX - svgRect.left;
                const mouseY = event.clientY - svgRect.top;
                const pointXBeforeZoom = (mouseX - evoViewBox.x) / evoZoomLevel;
                const pointYBeforeZoom = (mouseY - evoViewBox.y) / evoZoomLevel;
                let newZoomLevel = evoZoomLevel; 
                if (event.deltaY < 0) { newZoomLevel *= (1 + zoomIntensity); } 
                else { newZoomLevel *= (1 - zoomIntensity); }
                newZoomLevel = Math.max(0.05, Math.min(20, newZoomLevel)); 
                evoViewBox.x = mouseX - pointXBeforeZoom * newZoomLevel;
                evoViewBox.y = mouseY - pointYBeforeZoom * newZoomLevel;
                evoZoomLevel = newZoomLevel;
                applyEvoViewTransform();
            });
            evolutionSvgElement.addEventListener('mousedown', (event) => {
                if (event.button !== 0 || evoPlotSettings.isRunning) return; 
                evoIsPanning = true;
                evoLastPanPosition = { x: event.clientX, y: event.clientY };
                evolutionSvgElement.style.cursor = 'grabbing';
             });
            evolutionSvgElement.addEventListener('mousemove', (event) => {
                if (!evoIsPanning || evoPlotSettings.isRunning) return;
                const dx = event.clientX - evoLastPanPosition.x;
                const dy = event.clientY - evoLastPanPosition.y;
                evoViewBox.x += dx; evoViewBox.y += dy;
                evoLastPanPosition = { x: event.clientX, y: event.clientY };
                applyEvoViewTransform();
            });
            evolutionSvgElement.addEventListener('mouseup', () => { 
                if (evoIsPanning) {
                    evoIsPanning = false; evolutionSvgElement.style.cursor = 'grab';
                }
            });
            evolutionSvgElement.addEventListener('mouseleave', () => { 
                if (evoIsPanning) { evoIsPanning = false; evolutionSvgElement.style.cursor = 'grab';}
            });
        }

        window.toggleFullLog = () => { 
            fullOutputLog.style.display = (fullOutputLog.style.display === 'none' || fullOutputLog.style.display === '') ? 'block' : 'none';
            if (fullOutputLog.style.display === 'block') fullOutputLog.scrollTop = fullOutputLog.scrollHeight;
        };
        window.exportFullLog = () => {
             const blob = new Blob([fullOutputLog.value], { type: 'text/plain' }); const anchor = document.createElement('a');
             anchor.download = 'paired_binary_log.txt'; anchor.href = URL.createObjectURL(blob);
             anchor.click(); URL.revokeObjectURL(anchor.href);
         };
        window.clearFullLog = () => { fullOutputLog.value = ''; };

        document.addEventListener('DOMContentLoaded', initializeWasm);

    </script>
</body>
</html>
