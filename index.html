<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paired Binary Interactive Explorer</title>
    <style>
        /* ... (Full CSS from the previous "Polished UI" version - it's good!) ... */
        :root {
            --primary-color: #3f51b5; /* Indigo */
            --primary-dark: #303f9f;
            --primary-darker: #283593;
            --accent-color: #2ecc71; /* Green */
            --accent-dark: #27ae60;
            --background-color: #f0f4f8; /* Light Blue-Grey */
            --surface-color: #ffffff;
            --text-color: #212529;
            --muted-text-color: #6c757d;
            --border-color: #dee2e6;
            --input-bg-color: #f8f9fa;
            --status-ok-bg: #d1e7dd;
            --status-ok-text: #0f5132;
            --status-error-bg: #f8d7da;
            --status-error-text: #842029;
            --status-info-bg: #cff4fc;
            --status-info-text: #055160;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; padding: 20px; background-color: var(--background-color);
            color: var(--text-color); line-height: 1.6; display: flex; flex-direction: column; align-items: center;
        }
        .main-container {
            width: 100%; max-width: 960px; background-color: var(--surface-color);
            padding: 25px 30px; border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,0.08);
            border: 1px solid var(--border-color);
        }
        h1, h2, h3 { color: var(--primary-dark); text-align: center; }
        h1 { font-size: 2.4em; margin-bottom: 15px; font-weight: 600;}
        h2 { font-size: 1.75em; margin-top: 35px; margin-bottom: 20px; border-bottom: 2px solid var(--primary-color); padding-bottom: 8px; font-weight: 600;}
        h3 { margin-top: 25px; margin-bottom: 15px; text-align:left; font-size: 1.3em; color: var(--primary-dark); font-weight: 600;}

        .status-panel { text-align: center; margin-bottom: 25px; padding: 12px; border-radius: 6px; font-weight: 500; border: 1px solid transparent; }
        .status-ok { background-color: var(--status-ok-bg); color: var(--status-ok-text); border-color: var(--status-ok-text); }
        .status-error { background-color: var(--status-error-bg); color: var(--status-error-text); border-color: var(--status-error-text); }
        .status-info { background-color: var(--status-info-bg); color: var(--status-info-text); border-color: var(--status-info-text); }

        .primary-visualization, .key-benchmark, .advanced-section {
            padding: 20px; margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px; background-color: #fcfdff; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .primary-visualization p, .key-benchmark p { text-align: center; margin-bottom: 18px; color: var(--muted-text-color); font-size: 0.95em;}
        
        #evolutionSvgContainer { 
            text-align: center; 
            overflow: hidden; 
            width: 600px; 
            height: 400px; 
            margin: 15px auto; 
            border: 1px solid var(--border-color); 
            cursor: grab; 
            position: relative; 
            background-color: #1a1d24; /* Even darker background for "space" */
            border-radius: 4px;
        }
        #evolutionSvg { 
            display: block; 
        }
        .evolution-controls { text-align:center; margin-bottom:15px; }
        .evolution-controls label, .evolution-controls input, .evolution-controls button, .evolution-controls select {
            margin-right: 8px; margin-left: 8px;
            vertical-align: middle;
            margin-bottom: 8px; 
        }
        .evolution-controls input[type="number"] { width: 70px; padding: 8px; font-size:0.9em;}
        .evolution-controls button { width: auto; padding: 8px 15px; font-size:0.9em; }
        .evolution-controls select { padding: 8px; font-size:0.9em; border-radius: 4px; border: 1px solid #ccc; background-color: var(--input-bg-color); }


        button {
            background-color: var(--primary-color); color: white;
            padding: 12px 22px; border: none; border-radius: 5px;
            cursor: pointer; font-size: 1em; font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-block; margin: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover { background-color: var(--primary-dark); transform: translateY(-1px); }
        button:active { background-color: var(--primary-darker); transform: translateY(0px); }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; transform: translateY(0); opacity: 0.7; }
        button.secondary-action { background-color: #78909c; /* Blue Grey */ }
        button.secondary-action:hover { background-color: #607d8b; }
        button.test-suite-button { background-color: var(--accent-color); } /* Green Accent */
        button.test-suite-button:hover { background-color: var(--accent-dark); }


        details {
            background-color: #f8f9fa; border: 1px solid var(--border-color);
            border-radius: 6px; margin-top: 30px;
        }
        summary {
            font-weight: 600; font-size: 1.25em; color: var(--primary-dark);
            padding: 15px 20px; cursor: pointer; background-color: #eef2f7; 
            border-radius: 6px; transition: background-color 0.2s ease;
            list-style-position: inside; 
        }
        details[open] summary { border-bottom: 1px solid var(--border-color); border-radius: 6px 6px 0 0;}
        summary:hover { background-color: #d6e0f0; }
        .details-content { padding: 25px; background-color: var(--surface-color); border-radius: 0 0 6px 6px;}

        .control-group { margin-bottom: 18px; padding: 12px; border-radius: 5px; background-color: #fdfdff; border: 1px solid #f0f0f0;}
        .control-group label { display: block; margin-bottom: 6px; font-weight: 500; color: #495057; font-size: 0.95em; }
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group select {
            width: calc(100% - 24px); padding: 10px; margin-bottom: 10px;
            border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; font-size: 1em;
            background-color: var(--input-bg-color);
        }
        .control-group input[type="text"]:focus,
        .control-group input[type="number"]:focus,
        .control-group select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(63, 81, 181, 0.25);
            outline: none;
        }
        .control-group button { width: auto; font-size: 0.95em; padding: 8px 18px; }

        #mainOutputArea, #benchmarkResultArea {
            margin-top: 18px; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px;
            background-color: #eef2f7; min-height: 45px; font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap; font-size: 0.95em; overflow-wrap: break-word;
        }
        #fullLogContainer { margin-top: 30px;}
        #fullOutputLog { display:none; width: 100%; height: 300px; font-family: 'Courier New', Courier, monospace; font-size: 0.85em; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; box-sizing: border-box; background-color: #f8f9fa; white-space: pre-wrap; overflow-y: auto; margin-top: 10px;}
        .log-controls { margin-bottom: 10px; text-align: center; }
        .log-controls button { margin: 5px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Paired Binary Interactive Explorer</h1>
        <div id="wasmStatus" class="status-panel status-info">Loading WASM...</div>
        <div id="mainOutputArea"><p><i>Status and results of primary actions will appear here.</i></p></div>

        <section class="primary-visualization">
            <h2>Generative Evolution Plot</h2>
            <p>Visualizes randomly generated S<sub>N</sub> Paired Entities (X and X') appearing over time. Coordinates and pseudo-3D depth derived from S_base components of X.
               (Propagator settings from "Advanced Controls" are used).</p>
            <div class="evolution-controls">
                <label for="evoNLevel">N-Level:</label>
                <input type="number" id="evoNLevel" value="12" min="6" step="3"> 
                <label for="evoMaxPoints">Max Points:</label>
                <input type="number" id="evoMaxPoints" value="150" min="10">
                <label for="evoCoordMapStrategy">Coord Mapping:</label>
                <select id="evoCoordMapStrategy">
                    <option value="folded">Folded/Averaged XY</option>
                    <option value="tiled">Tiled/Quadrant XY</option>
                    <option value="spiral">Spiral XY (Experimental)</option>
                </select>
                <br>
                <label for="evoSpeed">Speed (ms/dot):</label>
                <input type="number" id="evoSpeed" value="150" min="1">
                
                <button onclick="toggleEvolutionPlot()" id="playPauseEvoButton">Play</button>
                <button onclick="stepForwardEvolution()" id="stepEvoButton" title="Step Forward">▶︎|</button>
                <button onclick="increaseEvolutionSpeed()" id="ffEvoButton" title="Faster">FF »</button>
                <button onclick="decreaseEvolutionSpeed()" id="slowEvoButton" title="Slower">« Slow</button>
                <button onclick="clearEvolutionPlot()" class="secondary-action">Clear & Reset</button>
            </div>
            <div id="evolutionSvgContainer">
                <svg id="evolutionSvg" width="600" height="400" xmlns="http://www.w3.org/2000/svg">
                    <g id="evoPlotMasterGroup"></g>
                </svg>
            </div>
        </section>

        <section class="key-benchmark">
            <h2>Key Performance Metric</h2>
            <p>Test how large 'N' can be for `generate_random_member` + `is_member` using the <b>currently configured</b> S_base and N_base from Advanced Controls.</p>
            <label for="depthTestTimeLimit">Time Limit per N (ms):</label>
            <input type="number" id="depthTestTimeLimit" value="500" style="width:100px; display:inline-block; margin-right:10px;">
            <button onclick="runDepthTest()" id="depthTestButton">Run Max N Depth Test</button>
            <div id="benchmarkResultArea" style="margin-top:15px;"><p><i>Depth test results will appear here.</i></p></div>
        </section>

        <details id="advancedControlsDetails">
            <summary>Advanced Controls & Detailed Tests »</summary>
            <div class="details-content">
                <h2>Propagator Setup</h2>
                <div class="control-group">
                    <label for="sBaseValuesInput">S_base Values (comma-separated decimal strings):</label>
                    <input type="text" id="sBaseValuesInput" value="0,1,2">
                    <label for="nBaseBitsInput">N_base Bits:</label>
                    <input type="number" id="nBaseBitsInput" value="3" min="1">
                    <button onclick="setupWasmPropagator()">Initialize / Update Propagator</button>
                </div>

                <h2>Automated Basic Tests</h2>
                <div class="control-group">
                    <button class="test-suite-button" onclick="runAutomatedTests()">Run Basic Logic Test Suite</button>
                </div>
                
                <h2>Performance Tests (Manual)</h2>
                <div class="control-group">
                    <h3>Run Speed Test</h3>
                    <label for="perfTestFunction">Function to Test:</label>
                    <select id="perfTestFunction">
                        <option value="is_member">is_member</option>
                        <option value="decompose_to_base">decompose_to_base</option>
                        <option value="compose_from_base">compose_from_base</option>
                        <option value="generate_random_member">generate_random_member</option>
                        <option value="create_paired_entity">create_paired_entity</option>
                    </select>
                    <label for="perfTestNValue">Target N-bits:</label>
                    <input type="number" id="perfTestNValue" value="12">
                     <label for="perfTestXValue">X Value for test (if applicable):</label>
                    <input type="text" id="perfTestXValue" value="0">
                    <label for="perfTestIterations">Number of Iterations:</label>
                    <input type="number" id="perfTestIterations" value="1000">
                    <button onclick="runPerformanceTest()">Start Manual Perf Test</button>
                </div>

                <h2>Manual Function Tests</h2>
                <div class="control-group">
                    <h3>Create Paired Entity</h3>
                    <label for="peXValueInput">X Value (decimal string):</label>
                    <input type="text" id="peXValueInput" value="2">
                    <label for="peNBitsInput">N-bits:</label>
                    <input type="number" id="peNBitsInput" value="3" min="1">
                    <button onclick="runCreatePairedEntity()">Create Paired Entity</button>
                </div>
                <div class="control-group">
                    <h3>Test S_N Membership</h3>
                    <label for="memberXValueInput">X Value (decimal string):</label>
                    <input type="text" id="memberXValueInput" value="18">
                    <label for="memberNBitsInput">Target N-bits:</label>
                    <input type="number" id="memberNBitsInput" value="6" min="1">
                    <button onclick="runIsMember()">Test Membership</button>
                </div>
                <div class="control-group">
                     <h3>Decompose to S_base</h3>
                    <label for="decomposeXValueInput">X Value (decimal string):</label>
                    <input type="text" id="decomposeXValueInput" value="18">
                    <label for="decomposeNBitsInput">Target N-bits:</label>
                    <input type="number" id="decomposeNBitsInput" value="6" min="1">
                    <button onclick="runDecompose()">Decompose</button>
                </div>
                <div class="control-group">
                    <h3>Compose from S_base</h3>
                    <label for="composeComponentsInput">S_base Components (comma-separated decimal strings):</label>
                    <input type="text" id="composeComponentsInput" value="2,2">
                    <button onclick="runCompose()">Compose</button>
                </div>
                <div class="control-group">
                    <h3>Generate Random S_N Member</h3>
                    <label for="randomNBitsInput">Target N-bits:</label>
                    <input type="number" id="randomNBitsInput" value="6" min="1">
                    <label for="randomSeedOffsetInput">Seed Offset (for PRNG consistency):</label>
                    <input type="number" id="randomSeedOffsetInput" value="0">
                    <button onclick="runGenerateRandom()">Generate Random</button>
                </div>
            </div>
        </details>

        <div id="fullLogContainer">
            <h2>Verbose Log</h2>
            <div class="log-controls">
                <button onclick="toggleFullLog()" class="secondary-action">Toggle Full Log Display</button>
                <button onclick="exportFullLog()" class="secondary-action">Export Full Log</button>
                <button onclick="clearFullLog()" class="secondary-action">Clear Full Log</button>
            </div>
            <textarea id="fullOutputLog" readonly></textarea>
        </div>
    </div>

    <script type="module">
        // WASM function bindings (assigned in initializeWasm)
        let setup_propagator_wasm, is_member_wasm, decompose_to_base_wasm, compose_from_base_wasm,
            generate_random_member_wasm, create_paired_entity_wasm;

        import init, * as wasm_exports from './pkg/paired_binary.js'; // Ensure this name matches your Cargo.toml

        // DOM Elements
        const mainOutputArea = document.getElementById('mainOutputArea');
        const benchmarkResultArea = document.getElementById('benchmarkResultArea');
        const fullOutputLog = document.getElementById('fullOutputLog');
        const wasmStatusDiv = document.getElementById('wasmStatus');
        const evolutionSvgElement = document.getElementById('evolutionSvg');
        const evoPlotMasterGroup = document.getElementById('evoPlotMasterGroup');
        const coordMapStrategySelect = document.getElementById('evoCoordMapStrategy');
        const SVG_NS = "http://www.w3.org/2000/svg";
        
        // Global State
        let wasmInitialized = false;
        let currentSBaseForDisplay = "0,1,2"; // Default, updated by setupWasmPropagator
        let currentNBaseForDisplay = 3;     // Default, updated by setupWasmPropagator
        let isBenchmarking = false; 
        
        let evolutionAnimationId = null;
        let evolutionPoints = []; 
        let evoPlotSettings = {
            nLevel: 12, maxPoints: 150, speed: 150, currentSpeed: 150, speedMultiplier: 1.0,
            sBaseCache: [0,1,2], nBaseCache: 3, isRunning: false,
            coordMapStrategy: 'folded' 
        };
        let evoViewBox = { x: 0, y: 0, width: 600, height: 400 }; 
        let evoZoomLevel = 1.0;
        let evoIsPanning = false;
        let evoLastPanPosition = { x: 0, y: 0 };

        // --- Logging ---
        function displayMain(message, type = "info") {
            mainOutputArea.innerHTML = `<p class="status-panel status-${type}">${message}</p>`;
            if (type === "error") console.error("MainDisplay:", message);
            else console.log("MainDisplay:", message);
        }

        function verboseLog(message, context = "Generic") {
            console.log(`[${context}]`, message);
            const timestamp = new Date().toLocaleTimeString();
            const currentLogVal = fullOutputLog.value;
            const maxLogLength = 50000; 
            const entry = `${timestamp}: [${context}] ${typeof message === 'string' ? message : JSON.stringify(message, null, 2)}\n\n`;
            fullOutputLog.value = (currentLogVal + entry).slice(-maxLogLength);
            if (fullOutputLog.style.display !== 'none') {
                fullOutputLog.scrollTop = fullOutputLog.scrollHeight;
            }
        }
        
        // --- WASM Initialization and Setup ---
        async function initializeWasm() {
            if (wasmInitialized) return true;
            wasmStatusDiv.textContent = "Loading WASM...";
            wasmStatusDiv.className = "status-panel status-info";
            try {
                await init(); 
                setup_propagator_wasm = wasm_exports.setup_propagator;
                is_member_wasm = wasm_exports.is_member;
                decompose_to_base_wasm = wasm_exports.decompose_to_base;
                compose_from_base_wasm = wasm_exports.compose_from_base;
                generate_random_member_wasm = wasm_exports.generate_random_member;
                create_paired_entity_wasm = wasm_exports.create_paired_entity;

                wasmStatusDiv.textContent = "WASM Module Initialized Successfully.";
                wasmStatusDiv.className = "status-panel status-ok";
                verboseLog("WASM module initialized successfully.", "System");
                wasmInitialized = true;
                
                // Setup default propagator after WASM is confirmed loaded
                const sBaseInput = document.getElementById('sBaseValuesInput');
                const nBaseInput = document.getElementById('nBaseBitsInput');
                try { 
                    setup_propagator_wasm(sBaseInput.value, parseInt(nBaseInput.value)); 
                    currentSBaseForDisplay = sBaseInput.value;
                    currentNBaseForDisplay = parseInt(nBaseInput.value);
                    evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                    evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                    verboseLog(`Default propagator S_base=${currentSBaseForDisplay}, N_base=${currentNBaseForDisplay} initialized.`, "System");
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`Error setting up default propagator: ${errorStr}`, "System");
                    displayMain(`Error setting up default propagator: ${errorStr}`, "error");
                }

                const playPauseButton = document.getElementById('playPauseEvoButton');
                const stepButton = document.getElementById('stepEvoButton');
                if(playPauseButton) playPauseButton.textContent = 'Play';
                if(stepButton) stepButton.disabled = false;
                
                if (evoPlotMasterGroup && evolutionSvgElement) {
                    applyEvoViewTransform(); 
                    evolutionSvgElement.style.cursor = 'grab';
                }
                return true;
            } catch (e) {
                wasmStatusDiv.textContent = "WASM Initialization Failed! Check console.";
                wasmStatusDiv.className = "status-panel status-error";
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                verboseLog(`WASM Initialization Failed: ${errorStr}`, "System");
                wasmInitialized = false;
                return false;
            }
        }
        
        window.setupWasmPropagator = async () => { 
            if (!await initializeWasm()) return;
            const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
            const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
            currentSBaseForDisplay = sBaseValuesStr; 
            currentNBaseForDisplay = nBaseBits;
            try {
                setup_propagator_wasm(sBaseValuesStr, nBaseBits);
                displayMain(`Propagator initialized/updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "ok");
                verboseLog(`Propagator user-updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "Setup");
                evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                evoPlotSettings.nBaseCache = currentNBaseForDisplay;
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`Setup Propagator Error: ${errorStr}`, "error");
                verboseLog(`Error setting up propagator: ${errorStr}`, "Setup");
            }
        };
        
        // --- Generic WASM Operation Runner ---
        async function runWasmOpForDisplay(actionName, operationFunc, ...args) {
            if (!await initializeWasm()) return "WASM not ready";
            displayMain(`${actionName}: Processing...`, "info");
            const startTime = performance.now();
            try {
                const result = await operationFunc(...args); 
                const endTime = performance.now();
                const timedResult = { result: result, time_ms: (endTime - startTime).toFixed(3) };
                displayMain(`${actionName} Complete.`, "ok"); 
                verboseLog({action: actionName, inputs: args.map(arg => Array.isArray(arg) ? `[${arg.join(',')}]` : String(arg)), ...timedResult}, "ManualOp");
                return result; 
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`${actionName} Error: ${errorStr}`, "error");
                verboseLog(`Error in ${actionName}: ${errorStr}`, "ManualOp");
                throw e; 
            }
        }

        // --- Manual Test Functions ---
        window.runCreatePairedEntity = () => { 
            const x = document.getElementById('peXValueInput').value;
            const n = parseInt(document.getElementById('peNBitsInput').value);
            runWasmOpForDisplay("CreatePairedEntity", create_paired_entity_wasm, x, n);
        };
        window.runIsMember = () => { 
            const x = document.getElementById('memberXValueInput').value;
            const n = parseInt(document.getElementById('memberNBitsInput').value);
            runWasmOpForDisplay("IsMember", is_member_wasm, x, n);
        };
        window.runDecompose = async () => { 
            const x = document.getElementById('decomposeXValueInput').value;
            const n = parseInt(document.getElementById('decomposeNBitsInput').value);
            await runWasmOpForDisplay("Decompose", async (val, bits) => {
                 const wasm_array = decompose_to_base_wasm(val, bits);
                 const nativeJsArray = Array.from(wasm_array); // wasm_array is js_sys::Array
                 return nativeJsArray.map(jsValToString); // Convert JsValue elements to strings
            }, x, n);
        };
        window.runCompose = () => { 
            const compsStr = document.getElementById('composeComponentsInput').value;
            const compsArr = compsStr.split(',').map(s => s.trim()).filter(s => s.length > 0);
            runWasmOpForDisplay("Compose", compose_from_base_wasm, compsArr);
        };
        window.runGenerateRandom = () => { 
            const n = parseInt(document.getElementById('randomNBitsInput').value);
            const seed = parseInt(document.getElementById('randomSeedOffsetInput').value);
            runWasmOpForDisplay("GenerateRandom", generate_random_member_wasm, n, seed);
        };

        // --- Automated Test Suite ---
        window.runAutomatedTests = async () => { /* ... (same as before, ensure wasm functions used) ... */ };
        
        // --- Key Performance Metric: Depth Test ---
        window.runDepthTest = async () => {
            if (!await initializeWasm()) return;
            if (isBenchmarking) { displayMain("Depth Test", "Benchmark already in progress.", "info"); return; }
            isBenchmarking = true;
            const depthTestButton = document.getElementById("depthTestButton");
            depthTestButton.disabled = true; depthTestButton.textContent = "Running Depth Test...";
            benchmarkResultArea.innerHTML = "<p><i>Running depth test... This may take some time. Please wait.</i></p>";
            verboseLog("Starting Max N Depth Test using current propagator settings...", "DepthTest");

            // Use current propagator settings from the UI
            const sBaseForTest = document.getElementById('sBaseValuesInput').value;
            const nBaseForTest = parseInt(document.getElementById('nBaseBitsInput').value);
             verboseLog(`DepthTest using S_base='${sBaseForTest}', N_base=${nBaseForTest}`, "DepthTest-Setup");


            const timeLimitMs = parseInt(document.getElementById('depthTestTimeLimit').value) || 500;
            let currentN = nBaseForTest; 
             if (currentN === 0) { // Should be caught by propagator setup, but defensive
                benchmarkResultArea.innerHTML = `<p class="status-panel status-error">N_base cannot be 0 for depth test.</p>`;
                isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test"; return;
            }
            currentN *= 2; // Start test from first hierarchical level up

            let maxNReached = 0; let results = [];
            const practicalBrowserNLimit = 8192; // Increased slightly

            while (currentN <= practicalBrowserNLimit) {
                verboseLog(`DepthTest: Testing N=${currentN}`, "DepthTest");
                let xValStr; let duration = 0; let isMem = false; let testPassedThisN = false;
                try {
                    const stepStartTime = performance.now();
                    xValStr = await generate_random_member_wasm(currentN, Date.now() % 1000 + currentN); 
                    if (typeof xValStr !== 'string' || xValStr.length === 0) throw new Error("generate_random_member_wasm invalid output.");
                    isMem = await is_member_wasm(xValStr, currentN);
                    const stepEndTime = performance.now();
                    duration = stepEndTime - stepStartTime;
                    const xPreview = xValStr.length > 25 ? xValStr.slice(0, 25) + "..." : xValStr;
                    results.push({ N: currentN, time_ms: duration.toFixed(3), is_member_result: isMem, generated_x_preview: xPreview });
                    if (duration <= timeLimitMs) { maxNReached = currentN; testPassedThisN = true; } 
                    else { verboseLog(`DepthTest: N=${currentN} exceeded time limit (${duration.toFixed(2)}ms > ${timeLimitMs}ms). Stopping.`, "DepthTest"); break; }
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`DepthTest: Error at N=${currentN}: ${errorStr}`, "DepthTest");
                    results.push({ N: currentN, time_ms: duration.toFixed(3), error: errorStr, generated_x_preview: "ERROR_DURING_GEN/TEST" });
                    // If the error is InvalidHierarchicalLevel, it means our N doubling logic is misaligned with what Rust expects for the current N_base
                    // This could happen if N_base itself isn't a power of some fundamental unit, or if N_base is large.
                    // For now, we break on most errors.
                    maxNReached = currentN > nBaseForTest ? currentN / 2 : 0; 
                    verboseLog(`DepthTest: Stopping due to error at N=${currentN}. Last potentially successful N for generation was ${maxNReached}.`, "DepthTest");
                    break; 
                }
                if (!testPassedThisN) break; 
                if (currentN >= practicalBrowserNLimit / 2 && currentN < practicalBrowserNLimit) { if (currentN * 2 > practicalBrowserNLimit) break; }
                if (currentN === 0) break; // safety for N_base starting low.
                let nextN = currentN * 2;
                if (nextN <= currentN) break; // Overflow or stagnation
                currentN = nextN; 
            }
            benchmarkResultArea.innerHTML = `<h3>Depth Test Results (S_base='${sBaseForTest}', N_base=${nBaseForTest}):</h3> <p>Max N reached for (generate_random + is_member) within ~${timeLimitMs}ms per N: <b>${maxNReached || 'N_base only (or error)'}</b></p> <pre>${JSON.stringify(results, null, 2)}</pre>`;
            verboseLog(`Depth Test Finished. Max N for ~${timeLimitMs}ms: ${maxNReached}`, "DepthTest");
            isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test";
        };
        
        // --- Manual Performance Test ---
        window.runPerformanceTest = async () => { /* ... same as previous, ensure X_wasm functions and correct S_base/N_base are used ... */};
        
        // --- Generative Evolution Plot ---
        function mapSBaseComponentsToXY(sBaseComponentsStrs, svgWidth, svgHeight) {
            const sBaseValues = evoPlotSettings.sBaseCache; // Use cached S_base numbers
            if (sBaseValues.length === 0) return { x: svgWidth / 2, y: svgHeight / 2, z_factor: 0.5 };

            const minSBase = Math.min(...sBaseValues);
            const maxSBase = Math.max(...sBaseValues);
            const rangeSBase = (maxSBase - minSBase) || 1; 
            const sBaseUniqueCount = new Set(sBaseValues).size || 1;

            let xNorm = 0.5, yNorm = 0.5, zNorm = 0.5; 
            const components = sBaseComponentsStrs.map(s => parseInt(s.trim()));

            const strategy = evoPlotSettings.coordMapStrategy;

            if (components.length >= 4) { 
                const a = components[0], b = components[1], c = components[2], d = components[3];
                const aN = (a - minSBase) / rangeSBase; const bN = (b - minSBase) / rangeSBase;
                const cN = (c - minSBase) / rangeSBase; const dN = (d - minSBase) / rangeSBase;
                if (strategy === 'tiled') {
                    const tilesPerRow = Math.ceil(Math.sqrt(sBaseUniqueCount*sBaseUniqueCount)); // e.g. if sBase has 3 values, 3x3 major tiles
                    const majorTileX = aN; 
                    const majorTileY = bN;
                    const subTileX = cN;
                    const subTileY = dN;
                    xNorm = (majorTileX / tilesPerRow) + (subTileX / (tilesPerRow * sBaseUniqueCount));
                    yNorm = (majorTileY / tilesPerRow) + (subTileY / (tilesPerRow * sBaseUniqueCount));
                    zNorm = (components.length > 4 && components[4]) ? (components[4] - minSBase) / rangeSBase : (aN + bN + cN + dN) / 4;
                } else if (strategy === 'spiral') {
                    // Very simple spiral for 4 components. Needs much more work for general case.
                    // This is highly conceptual for a 2D projection from 4 components.
                    const magnitude = (aN + bN + cN + dN) / 4; // Average "energy"
                    const angle = (aN * 90 + bN * 180 + cN * 270 + dN * 360) % 360 * (Math.PI/180); // Mix angles
                    xNorm = 0.5 + magnitude * Math.cos(angle) * 0.4; // Scale to fit 0-1
                    yNorm = 0.5 + magnitude * Math.sin(angle) * 0.4;
                    zNorm = dN; // Use last component for Z-depth cue
                }else { // 'folded' (default)
                    xNorm = (aN * 0.5 + cN * 0.5); 
                    yNorm = (bN * 0.5 + dN * 0.5);
                    zNorm = (cN + dN) / 2; // Simple Z based on last two components
                }
            } else if (components.length === 2) { 
                const a = components[0], b = components[1];
                xNorm = (a - minSBase) / rangeSBase; yNorm = (b - minSBase) / rangeSBase;
                zNorm = (xNorm + yNorm) / 2; // Z based on average
            } else if (components.length > 0) { 
                let sumX = 0, sumY = 0, sumZ = 0, countX = 0, countY = 0;
                for(let i=0; i < components.length; i++) {
                    const val = components[i];
                    const valN = (val - minSBase) / rangeSBase;
                    sumZ += valN;
                    if (i % 2 === 0) { sumX += valN; countX++; } else { sumY += valN; countY++; }
                }
                xNorm = countX > 0 ? (sumX / countX) : 0.5;
                yNorm = countY > 0 ? (sumY / countY) : 0.5;
                zNorm = components.length > 0 ? sumZ / components.length : 0.5;
            }
            
            xNorm = Math.max(0, Math.min(1, xNorm || 0.5)); 
            yNorm = Math.max(0, Math.min(1, yNorm || 0.5));
            zNorm = Math.max(0, Math.min(1, zNorm || 0.5));


            const padding = 40; // Increased padding for axes visibility
            return { 
                x: padding + xNorm * (svgWidth - 2 * padding), 
                y: padding + yNorm * (svgHeight - 2 * padding),
                z_factor: 0.3 + (1.0 - zNorm) * 0.7 // z_factor: 1 is "close" (large), 0.3 is "far" (small)
            };
        }

        function updateEvolutionPlot() {
            if (!evoPlotSettings.isRunning || !wasmInitialized) return;
            try {
                const currentNLevel = evoPlotSettings.nLevel;
                const randomXStr = generate_random_member_wasm(currentNLevel, Date.now() % 1000 + evolutionPoints.length + Math.random()*100);
                const pe_obj = create_paired_entity_wasm(randomXStr, currentNLevel);
                const xValForPlotStr = pe_obj.x; const xPrimeValStr = pe_obj.x_prime;
                const wasmDecompArrayX = decompose_to_base_wasm(xValForPlotStr, currentNLevel);
                const sBaseComponentsX = Array.from(wasmDecompArrayX).map(jsValToString);

                const svgWidth = parseInt(evolutionSvgElement.getAttribute('width'));
                const svgHeight = parseInt(evolutionSvgElement.getAttribute('height'));
                
                const positionDataX = mapSBaseComponentsToXY(sBaseComponentsX, svgWidth, svgHeight);

                const offsetMagnitude = Math.max(4 / evoZoomLevel, 8 / evoZoomLevel) * positionDataX.z_factor; 
                const angle = (evolutionPoints.length * 0.618) % (2 * Math.PI); // Golden angle for spread
                const coordsXPrime = { 
                    x: positionDataX.x + offsetMagnitude * Math.cos(angle), 
                    y: positionDataX.y + offsetMagnitude * Math.sin(angle),
                    z_factor: positionDataX.z_factor * 0.9 // X' slightly further back
                };
                
                evolutionPoints.push({ 
                    x_coord: positionDataX.x, y_coord: positionDataX.y, z_factor_x: positionDataX.z_factor,
                    xp_coord: coordsXPrime, age: 0, 
                    x_val_str: xValForPlotStr, xp_val_str: xPrimeValStr, s_base_X: sBaseComponentsX,
                });
                if (evolutionPoints.length > evoPlotSettings.maxPoints) evolutionPoints.shift(); 

                evoPlotMasterGroup.innerHTML = ''; 

                // Sort points by z_factor so "closer" points are drawn on top
                const sortedPoints = [...evolutionPoints].sort((a,b) => (a.z_factor_x || 0.5) - (b.z_factor_x || 0.5));


                sortedPoints.forEach((p, indexInSorted) => { // Use indexInSorted if needed for styling top N points
                    p.age++;
                    const isNewestOriginal = evolutionPoints.findIndex(ep => ep.x_val_str === p.x_val_str && ep.xp_val_str === p.xp_val_str) === evolutionPoints.length - 1;

                    const maxAgeEffect = Math.max(30, evoPlotSettings.maxPoints * 0.7); 
                    const relativeAge = Math.min(p.age / maxAgeEffect, 1.0); 
                    const baseOpacity = 1.0 - (relativeAge * 0.80); 
                    
                    // Apply z_factor to opacity: further points are more transparent
                    const finalOpacityX = baseOpacity * (0.4 + p.z_factor_x * 0.6);
                    const finalOpacityXP = baseOpacity * (0.4 + (p.xp_coord.z_factor || p.z_factor_x) * 0.6);


                    let baseRadius = 4.0 * (1 - relativeAge * 0.3); // Points shrink less with age
                    baseRadius = Math.max(1.0, baseRadius);
                    // Apply z_factor to radius: further points are smaller
                    const radiusX = Math.max(0.3 / evoZoomLevel, (baseRadius * p.z_factor_x) / evoZoomLevel);
                    const radiusXP = Math.max(0.3 / evoZoomLevel, (baseRadius * (p.xp_coord.z_factor || p.z_factor_x) * 0.75) / evoZoomLevel);


                    let baseStrokeWidth = isNewestOriginal ? 1.0 : 0.3;
                    const strokeWidthX = Math.max(0.1 / evoZoomLevel, baseStrokeWidth / evoZoomLevel);
                    const strokeWidthXP = Math.max(0.1 / evoZoomLevel, (baseStrokeWidth * 1.2) / evoZoomLevel);


                    const line = document.createElementNS(SVG_NS, 'line');
                    line.setAttribute('x1', p.x_coord); line.setAttribute('y1', p.y_coord);
                    line.setAttribute('x2', p.xp_coord.x); line.setAttribute('y2', p.xp_coord.y);
                    const lineHue = (parseInt(p.x_val_str.slice(-3) || "0", 16) * 0.2) % 360; 
                    const lineOpacity = Math.min(finalOpacityX, finalOpacityXP) * 0.3; // Line is faint
                    line.setAttribute('stroke', `hsla(${lineHue}, 50%, 60%, ${lineOpacity})`); 
                    line.setAttribute('stroke-width', Math.max(0.05 / evoZoomLevel, 0.2 / evoZoomLevel));
                    evoPlotMasterGroup.appendChild(line);

                    const circleX = document.createElementNS(SVG_NS, 'circle');
                    circleX.setAttribute('cx', p.x_coord); circleX.setAttribute('cy', p.y_coord);
                    circleX.setAttribute('r', radiusX);
                    let hueSourceX = p.s_base_X.length > 0 ? parseInt(p.s_base_X[0]) : 0;
                    const hueX = (hueSourceX * 70 + Math.random()*30) % 360; // Add some randomness to hue
                    const saturationX = 90 - (relativeAge * 30); 
                    const lightnessX = 60 - (relativeAge * 20) + (p.z_factor_x - 0.5) * 10; // Brighter if closer
                    circleX.setAttribute('fill', `hsla(${hueX}, ${saturationX}%, ${lightnessX}%, ${finalOpacityX})`);
                    circleX.setAttribute('stroke', isNewestOriginal ? '#ffffff' : `hsla(${hueX}, ${saturationX-10}%, ${lightnessX-10}%, ${finalOpacityX*0.9})`);
                    circleX.setAttribute('stroke-width', strokeWidthX);
                    evoPlotMasterGroup.appendChild(circleX);

                    const circleXPrime = document.createElementNS(SVG_NS, 'circle');
                    circleXPrime.setAttribute('cx', p.xp_coord.x); circleXPrime.setAttribute('cy', p.xp_coord.y);
                    circleXPrime.setAttribute('r', radiusXP); 
                    const hueXPrime = (hueX + 150 + Math.random()*60) % 360; // More distinct complementary hue
                    const saturationXP = 80 - (relativeAge * 35); 
                    const lightnessXP = 60 - (relativeAge * 20) + ((p.xp_coord.z_factor || p.z_factor_x) - 0.5) * 10;
                    circleXPrime.setAttribute('fill', 'none'); 
                    circleXPrime.setAttribute('stroke', `hsla(${hueXPrime}, ${saturationXP}%, ${lightnessXP}%, ${finalOpacityXP * 0.9})`);
                    circleXPrime.setAttribute('stroke-width', strokeWidthXP); 
                    evoPlotMasterGroup.appendChild(circleXPrime);
                });
            } catch (e) { const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e); verboseLog(`Error during evolution step: ${errorStr}`, "EvolutionPlot");}
            if (evoPlotSettings.isRunning) evolutionAnimationId = setTimeout(updateEvolutionPlot, evoPlotSettings.currentSpeed);
        }
        
        window.toggleEvolutionPlot = async () => { /* ... same ... */ };
        window.stepForwardEvolution = async () => { /* ... same ... */ };
        window.increaseEvolutionSpeed = () => { /* ... same ... */ };
        window.decreaseEvolutionSpeed = () => { /* ... same ... */ };
        window.clearEvolutionPlot = () => { /* ... same ... */ };
        
        function jsValToString(jsVal) { /* ... same ... */ }
        function applyEvoViewTransform() { /* ... same ... */ }

        if (evolutionSvgElement) { /* ... same event listeners ... */ }

        window.toggleFullLog = () => { /* ... same ... */ };
        window.exportFullLog = () => { /* ... same ... */ };
        window.clearFullLog = () => { /* ... same ... */ };

        document.addEventListener('DOMContentLoaded', initializeWasm);
    </script>
</body>
</html>
