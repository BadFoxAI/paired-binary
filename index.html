        // ... (import statements and existing global JS variables) ...
        // const evolutionSvgElement = document.getElementById('evolutionSvg'); // Already have this
        const evoPlotMasterGroup = document.getElementById('evoPlotMasterGroup'); // New master <g> element

        // New state variables for zoom/pan
        let evoViewBox = { x: 0, y: 0, width: 600, height: 400 }; // Initial viewbox, matches SVG size
        let evoZoomLevel = 1;
        let evoIsPanning = false;
        let evoLastPanPosition = { x: 0, y: 0 };

        // Modify evoPlotSettings
        let evoPlotSettings = {
            nLevel: 12,
            maxPoints: 200,
            speed: 100, // Base speed
            currentSpeed: 100, // Actual speed used by timeout
            speedMultiplier: 1,
            sBaseCache: [0,1,2],
            nBaseCache: 3,
            isRunning: false
        };
        
        // --- New Zoom/Pan Functions ---
        function applyEvoViewTransform() {
            // Instead of changing viewbox, we transform the master group
            // This makes coordinate calculations for points simpler as they are always in original SVG space
            evoPlotMasterGroup.setAttribute('transform', `translate(${evoViewBox.x}, ${evoViewBox.y}) scale(${evoZoomLevel})`);
        }

        evolutionSvgElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            const zoomIntensity = 0.1;
            const svgRect = evolutionSvgElement.getBoundingClientRect();
            
            // Mouse position relative to SVG element
            const mouseX = event.clientX - svgRect.left;
            const mouseY = event.clientY - svgRect.top;

            // Coordinates in SVG space before zoom (considering current pan and zoom)
            const pointXBeforeZoom = (mouseX - evoViewBox.x) / evoZoomLevel;
            const pointYBeforeZoom = (mouseY - evoViewBox.y) / evoZoomLevel;

            let newZoomLevel = evoZoomLevel;
            if (event.deltaY < 0) { // Zoom in
                newZoomLevel *= (1 + zoomIntensity);
            } else { // Zoom out
                newZoomLevel *= (1 - zoomIntensity);
            }
            newZoomLevel = Math.max(0.1, Math.min(10, newZoomLevel)); // Clamp zoom level

            // Adjust pan (evoViewBox.x, evoViewBox.y) to keep mouse pointer over same SVG point
            evoViewBox.x = mouseX - pointXBeforeZoom * newZoomLevel;
            evoViewBox.y = mouseY - pointYBeforeZoom * newZoomLevel;
            
            evoZoomLevel = newZoomLevel;
            applyEvoViewTransform();
        });

        evolutionSvgElement.addEventListener('mousedown', (event) => {
            if (event.button !== 0) return; // Only left click
            evoIsPanning = true;
            evoLastPanPosition = { x: event.clientX, y: event.clientY };
            evolutionSvgElement.style.cursor = 'grabbing';
        });

        evolutionSvgElement.addEventListener('mousemove', (event) => {
            if (!evoIsPanning) return;
            const dx = event.clientX - evoLastPanPosition.x;
            const dy = event.clientY - evoLastPanPosition.y;
            
            evoViewBox.x += dx;
            evoViewBox.y += dy;
            
            evoLastPanPosition = { x: event.clientX, y: event.clientY };
            applyEvoViewTransform();
        });

        evolutionSvgElement.addEventListener('mouseup', () => {
            evoIsPanning = false;
            evolutionSvgElement.style.cursor = 'grab';
        });
        evolutionSvgElement.addEventListener('mouseleave', () => { // Stop panning if mouse leaves SVG
            if (evoIsPanning) {
                evoIsPanning = false;
                evolutionSvgElement.style.cursor = 'grab';
            }
        });


        // --- Modified Evolution Plot Functions ---
        function updateEvolutionPlot() {
            if (!evoPlotSettings.isRunning || !wasmInitialized) return;

            try {
                const randomXStr = generate_random_member_wasm(evoPlotSettings.nLevel, Date.now() % 1000 + evolutionPoints.length);
                const wasmDecompArray = decompose_to_base_wasm(randomXStr, evoPlotSettings.nLevel);
                const sBaseComponents = Array.from(wasmDecompArray).map(jsValToString);

                const svgWidth = parseInt(evolutionSvgElement.getAttribute('width'));
                const svgHeight = parseInt(evolutionSvgElement.getAttribute('height'));
                // The mapSBaseComponentsToXY function now doesn't need to know about zoom/pan
                // It always maps to the original 0-width, 0-height SVG coordinate space
                const coords = mapSBaseComponentsToXY(sBaseComponents, evoPlotSettings.nBaseCache, svgWidth, svgHeight);

                evolutionPoints.push({ x: coords.x, y: coords.y, age: 0, val: randomXStr, s_base: sBaseComponents });
                if (evolutionPoints.length > evoPlotSettings.maxPoints) {
                    evolutionPoints.shift(); 
                }

                // Clear only the master group for redrawing points
                evoPlotMasterGroup.innerHTML = ''; 

                evolutionPoints.forEach((p, index) => {
                    p.age++;
                    const circle = document.createElementNS(SVG_NS, 'circle');
                    // Coordinates are absolute within the SVG, transform on master group handles view
                    circle.setAttribute('cx', p.x);
                    circle.setAttribute('cy', p.y);
                    
                    const maxAgeEffect = Math.max(50, evoPlotSettings.maxPoints * 0.8); 
                    const relativeAge = Math.min(p.age / maxAgeEffect, 1.0); 

                    // Adjust radius based on zoom level so points don't become too big/small
                    let radius = (5 / evoZoomLevel) * (1 - relativeAge * 0.7); 
                    radius = Math.max(1 / evoZoomLevel, radius); // Minimum visible radius
                    circle.setAttribute('r', radius);

                    let hueSource = p.s_base.length > 0 ? parseInt(p.s_base[0]) : 0;
                    const hue = (hueSource * 60) % 360; 
                    const saturation = 100 - (relativeAge * 60);
                    const lightness = 65 - (relativeAge * 35);
                    const opacity = 0.85 - (relativeAge * 0.7);

                    circle.setAttribute('fill', `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity})`);
                    
                    let strokeWidth = (index === evolutionPoints.length - 1) ? (1.5 / evoZoomLevel) : (0.5 / evoZoomLevel);
                    strokeWidth = Math.max(0.2, strokeWidth); // Min stroke width
                    circle.setAttribute('stroke-width', strokeWidth);
                    circle.setAttribute('stroke', (index === evolutionPoints.length - 1) ? '#fff' : `hsla(${hue}, ${saturation-20}%, ${lightness-20}%, ${opacity*0.8})`);
                    
                    evoPlotMasterGroup.appendChild(circle);
                });

            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                verboseLog(`Error during evolution step: ${errorStr}`, "EvolutionPlot");
            }

            if (evoPlotSettings.isRunning) {
                evolutionAnimationId = setTimeout(updateEvolutionPlot, evoPlotSettings.currentSpeed);
            }
        }
        
        window.toggleEvolutionPlot = async () => {
            if (!await initializeWasm()) return;

            if (evoPlotSettings.isRunning) { // Pause
                evoPlotSettings.isRunning = false;
                if (evolutionAnimationId) clearTimeout(evolutionAnimationId);
                document.getElementById('playPauseEvoButton').textContent = 'Play';
                document.getElementById('stepEvoButton').disabled = false;
                verboseLog("Evolution plot paused.", "EvolutionPlot");
                displayMain("Evolution Plot", "Paused.", "info");
            } else { // Play
                evoPlotSettings.nLevel = parseInt(document.getElementById('evoNLevel').value) || 12;
                evoPlotSettings.maxPoints = parseInt(document.getElementById('evoMaxPoints').value) || 200;
                evoPlotSettings.speed = parseInt(document.getElementById('evoSpeed').value) || 100;
                evoPlotSettings.currentSpeed = evoPlotSettings.speed / evoPlotSettings.speedMultiplier; // Apply multiplier

                const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
                const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
                if (currentSBaseForDisplay !== sBaseValuesStr || currentNBaseForDisplay !== nBaseBits) {
                    displayMain("Evolution Plot Info", "Propagator settings changed. Re-initializing for plot.", "info");
                    try {
                        setup_propagator_wasm(sBaseValuesStr, nBaseBits);
                        currentSBaseForDisplay = sBaseValuesStr;
                        currentNBaseForDisplay = nBaseBits;
                    } catch(e) { displayMain("Evolution Plot Error", "Could not set propagator.", "error"); return; }
                }
                evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
                evoPlotSettings.nBaseCache = currentNBaseForDisplay;
                if (evoPlotSettings.sBaseCache.length === 0) {
                    displayMain("Evolution Plot Error", "S_base values are not valid numbers or are empty.", "error"); return;
                }

                evoPlotSettings.isRunning = true;
                document.getElementById('playPauseEvoButton').textContent = 'Pause';
                document.getElementById('startEvoButton').disabled = true; // Keep old start button behavior (or remove it)
                document.getElementById('stopEvoButton').disabled = true; // Legacy stop, new button is play/pause
                document.getElementById('stepEvoButton').disabled = true;

                verboseLog(`Evolution plot started/resumed: N=${evoPlotSettings.nLevel}, MaxPts=${evoPlotSettings.maxPoints}, Speed=${evoPlotSettings.currentSpeed}ms`, "EvolutionPlot");
                displayMain("Evolution Plot", `Running for N=${evoPlotSettings.nLevel}...`, "info");
                updateEvolutionPlot();
            }
        };
        
        // Replace startEvolutionPlot with toggle or make start call toggle
        window.startEvolutionPlot = () => {
             if (!evoPlotSettings.isRunning) toggleEvolutionPlot();
        }
        // Replace stopEvolutionPlot with toggle or make stop call toggle
        window.stopEvolutionPlot = () => {
            if (evoPlotSettings.isRunning) toggleEvolutionPlot();
        }


        window.stepForwardEvolution = async () => {
            if (!await initializeWasm()) return;
            if (evoPlotSettings.isRunning) { // If running, pause first
                toggleEvolutionPlot(); // This will pause it
            }
            // Ensure settings are loaded if not already running
            evoPlotSettings.nLevel = parseInt(document.getElementById('evoNLevel').value) || 12;
            evoPlotSettings.maxPoints = parseInt(document.getElementById('evoMaxPoints').value) || 200;
            const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
            const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
            if (currentSBaseForDisplay !== sBaseValuesStr || currentNBaseForDisplay !== nBaseBits) {
                 try { setup_propagator_wasm(sBaseValuesStr, nBaseBits); currentSBaseForDisplay = sBaseValuesStr; currentNBaseForDisplay = nBaseBits; } catch(e) { /* ... */ }
            }
            evoPlotSettings.sBaseCache = currentSBaseForDisplay.split(',').map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));
            evoPlotSettings.nBaseCache = currentNBaseForDisplay;


            verboseLog("Stepping forward evolution plot.", "EvolutionPlot");
            updateEvolutionPlot(); // Call once to draw one frame
        };

        window.increaseEvolutionSpeed = () => {
            evoPlotSettings.speedMultiplier *= 2;
            if (evoPlotSettings.speedMultiplier > 16) evoPlotSettings.speedMultiplier = 16; // Max 16x
            evoPlotSettings.currentSpeed = Math.max(10, evoPlotSettings.speed / evoPlotSettings.speedMultiplier);
            displayMain("Evolution Plot", `Speed: ${evoPlotSettings.speedMultiplier}x (Interval: ${evoPlotSettings.currentSpeed.toFixed(0)}ms)`, "info");
            verboseLog(`Evolution speed increased to ${evoPlotSettings.speedMultiplier}x`, "EvolutionPlot");
        };
        
        window.decreaseEvolutionSpeed = () => {
            evoPlotSettings.speedMultiplier /= 2;
            if (evoPlotSettings.speedMultiplier < 0.125) evoPlotSettings.speedMultiplier = 0.125; // Min 1/8x
            evoPlotSettings.currentSpeed = evoPlotSettings.speed / evoPlotSettings.speedMultiplier;
             displayMain("Evolution Plot", `Speed: ${evoPlotSettings.speedMultiplier}x (Interval: ${evoPlotSettings.currentSpeed.toFixed(0)}ms)`, "info");
            verboseLog(`Evolution speed decreased to ${evoPlotSettings.speedMultiplier}x`, "EvolutionPlot");
        };


        window.clearEvolutionPlot = () => {
            if (evoPlotSettings.isRunning) toggleEvolutionPlot(); // Pause if running
            evolutionPoints = [];
            evoPlotMasterGroup.innerHTML = ''; // Clear the master group
            // Reset zoom/pan
            evoViewBox = { x: 0, y: 0, width: 600, height: 400 }; 
            evoZoomLevel = 1;
            applyEvoViewTransform();

            verboseLog("Evolution plot cleared and view reset.", "EvolutionPlot");
            displayMain("Evolution Plot", "Cleared and view reset.", "info");
            document.getElementById('playPauseEvoButton').textContent = 'Play';
            document.getElementById('stepEvoButton').disabled = false;

        };
        
        // Helper for JS array mapping (already existed, ensure it's here)
        function jsValToString(jsVal) { 
            return (typeof jsVal === 'string') ? jsVal : (jsVal && typeof jsVal.as_string === 'function') ? jsVal.as_string() : String(jsVal);
        }

        // Initialize WASM on page load
        // Make sure to call applyEvoViewTransform after SVG is definitely in DOM and sized
        // And set initial cursor for SVG
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeWasm();
            if (wasmInitialized) {
                 applyEvoViewTransform(); // Apply initial transform
                 evolutionSvgElement.style.cursor = 'grab';
                 document.getElementById('playPauseEvoButton').textContent = 'Play';
                 document.getElementById('stepEvoButton').disabled = false;
            }
        });

        // ... (All other JS functions: initializeWasm, setupWasmPropagator, runAutomatedTests, runDepthTest, runPerformanceTest,
        //      manual test functions, log controls, etc. should be the same as the previous full HTML version) ...
        //      I've included the full initializeWasm and setupWasmPropagator for context.
        //      The manual test functions (runCreatePairedEntity etc.) should also be present.

    </script>
</body>
</html>
