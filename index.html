<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paired Binary Interactive Explorer</title>
    <style>
        :root {
            --primary-color: #3f51b5; /* Indigo */
            --primary-dark: #303f9f;
            --primary-darker: #283593;
            --accent-color: #2ecc71; /* Green */
            --accent-dark: #27ae60;
            --background-color: #f0f4f8; /* Light Blue-Grey */
            --surface-color: #ffffff;
            --text-color: #212529;
            --muted-text-color: #6c757d;
            --border-color: #dee2e6;
            --input-bg-color: #f8f9fa;
            --status-ok-bg: #d1e7dd;
            --status-ok-text: #0f5132;
            --status-error-bg: #f8d7da;
            --status-error-text: #842029;
            --status-info-bg: #cff4fc;
            --status-info-text: #055160;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; padding: 20px; background-color: var(--background-color);
            color: var(--text-color); line-height: 1.6; display: flex; flex-direction: column; align-items: center;
        }
        .main-container {
            width: 100%; max-width: 960px; background-color: var(--surface-color);
            padding: 25px 30px; border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,0.08);
            border: 1px solid var(--border-color);
        }
        h1, h2, h3 { color: var(--primary-dark); text-align: center; }
        h1 { font-size: 2.4em; margin-bottom: 15px; font-weight: 600;}
        h2 { font-size: 1.75em; margin-top: 35px; margin-bottom: 20px; border-bottom: 2px solid var(--primary-color); padding-bottom: 10px; font-weight: 600;}
        h3 { margin-top: 25px; margin-bottom: 15px; text-align:left; font-size: 1.3em; color: var(--primary-dark); font-weight: 600;}

        .status-panel { text-align: center; margin-bottom: 25px; padding: 12px; border-radius: 6px; font-weight: 500; border: 1px solid transparent; }
        .status-ok { background-color: var(--status-ok-bg); color: var(--status-ok-text); border-color: var(--status-ok-text); }
        .status-error { background-color: var(--status-error-bg); color: var(--status-error-text); border-color: var(--status-error-text); }
        .status-info { background-color: var(--status-info-bg); color: var(--status-info-text); border-color: var(--status-info-text); }

        .primary-visualization, .key-benchmark, .advanced-section {
            padding: 20px; margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px; background-color: #fcfdff; /* Slightly off-white */
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .primary-visualization p, .key-benchmark p { text-align: center; margin-bottom: 18px; color: var(--muted-text-color); font-size: 0.95em;}
        
        #s6SvgContainer { text-align: center; }
        #s6Svg { border: 1px solid var(--border-color); background-color: var(--surface-color); border-radius: 4px;}

        button {
            background-color: var(--primary-color); color: white;
            padding: 12px 22px; border: none; border-radius: 5px;
            cursor: pointer; font-size: 1em; font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-block; margin: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover { background-color: var(--primary-dark); transform: translateY(-1px); }
        button:active { background-color: var(--primary-darker); transform: translateY(0px); }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; transform: translateY(0); }
        button.secondary-action { background-color: #78909c; /* Blue Grey */ }
        button.secondary-action:hover { background-color: #607d8b; }
        button.test-suite-button { background-color: var(--accent-color); }
        button.test-suite-button:hover { background-color: var(--accent-dark); }

        details {
            background-color: #f8f9fa; border: 1px solid var(--border-color);
            border-radius: 6px; margin-top: 30px;
        }
        summary {
            font-weight: 600; font-size: 1.25em; color: var(--primary-dark);
            padding: 15px 20px; cursor: pointer; background-color: #eef2f7; /* Lighter Indigo */
            border-radius: 6px; transition: background-color 0.2s ease;
            list-style-position: inside; /* For better alignment of marker */
        }
        details[open] summary { border-bottom: 1px solid var(--border-color); border-radius: 6px 6px 0 0;}
        summary:hover { background-color: #d6e0f0; }
        .details-content { padding: 25px; background-color: var(--surface-color); border-radius: 0 0 6px 6px;}

        .control-group { margin-bottom: 18px; padding: 12px; border-radius: 5px; background-color: #fdfdff; border: 1px solid #f0f0f0;}
        .control-group label { display: block; margin-bottom: 6px; font-weight: 500; color: #495057; font-size: 0.95em; }
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group select {
            width: calc(100% - 24px); padding: 10px; margin-bottom: 10px;
            border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; font-size: 1em;
            background-color: var(--input-bg-color);
        }
        .control-group input[type="text"]:focus,
        .control-group input[type="number"]:focus,
        .control-group select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(63, 81, 181, 0.25);
            outline: none;
        }
        .control-group button { width: auto; font-size: 0.95em; padding: 8px 18px; }

        #mainOutputArea, #benchmarkResultArea {
            margin-top: 18px; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px;
            background-color: #eef2f7; min-height: 45px; font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap; font-size: 0.95em; overflow-wrap: break-word;
        }
        #fullLogContainer { margin-top: 30px;}
        #fullOutputLog { display:none; width: 100%; height: 300px; font-family: 'Courier New', Courier, monospace; font-size: 0.85em; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; box-sizing: border-box; background-color: #f8f9fa; white-space: pre-wrap; overflow-y: auto; margin-top: 10px;}
        .log-controls { margin-bottom: 10px; text-align: center; }
        .log-controls button { margin: 5px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Paired Binary Interactive Explorer</h1>
        <div id="wasmStatus" class="status-panel status-info">Loading WASM...</div>
        <div id="mainOutputArea"><p><i>Status and results of primary actions will appear here.</i></p></div>

        <section class="primary-visualization">
            <h2>S6 Dot Visualization (for S3={0,1,2})</h2>
            <p>Displays the 9 members of S6 generated from S_base={0,1,2} with N_base=3. Each dot is an X-value. Requires propagator to be set to these S_base values.</p>
            <div style="text-align:center;">
                 <button onclick="drawS6VisualizationSVG()" id="drawS6Button">Draw S6 SVG Plot</button>
            </div>
            <div id="s6SvgContainer" style="margin-top:15px;">
                <svg id="s6Svg" width="360" height="360" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
        </section>

        <section class="key-benchmark">
            <h2>Key Performance Metric</h2>
            <p>Test how large 'N' can be for `generate_random_member` + `is_member` to complete within a target time.
               (This test temporarily sets S_base to {0,1,2}, N_base=3 for consistency.)</p>
            <label for="depthTestTimeLimit">Time Limit per N (ms):</label>
            <input type="number" id="depthTestTimeLimit" value="500" style="width:100px; display:inline-block; margin-right:10px;">
            <button onclick="runDepthTest()" id="depthTestButton">Run Max N Depth Test</button>
            <div id="benchmarkResultArea" style="margin-top:15px;"><p><i>Depth test results will appear here.</i></p></div>
        </section>

        <details id="advancedControlsDetails">
            <summary>Advanced Controls & Detailed Tests Â»</summary>
            <div class="details-content">
                <h2>Propagator Setup</h2>
                <div class="control-group">
                    <label for="sBaseValuesInput">S_base Values (comma-separated decimal strings):</label>
                    <input type="text" id="sBaseValuesInput" value="0,1,2">
                    <label for="nBaseBitsInput">N_base Bits:</label>
                    <input type="number" id="nBaseBitsInput" value="3" min="1">
                    <button onclick="setupWasmPropagator()">Initialize / Update Propagator</button>
                </div>

                <h2>Automated Basic Tests</h2>
                <div class="control-group">
                    <button class="test-suite-button" onclick="runAutomatedTests()">Run Basic Logic Test Suite</button>
                </div>
                
                <h2>Performance Tests (Manual)</h2>
                <div class="control-group">
                    <h3>Run Speed Test</h3>
                    <label for="perfTestFunction">Function to Test:</label>
                    <select id="perfTestFunction">
                        <option value="is_member">is_member</option>
                        <option value="decompose_to_base">decompose_to_base</option>
                        <option value="compose_from_base">compose_from_base</option>
                        <option value="generate_random_member">generate_random_member</option>
                        <option value="create_paired_entity">create_paired_entity</option>
                    </select>
                    <label for="perfTestNValue">Target N-bits:</label>
                    <input type="number" id="perfTestNValue" value="12">
                     <label for="perfTestXValue">X Value for test (if applicable):</label>
                    <input type="text" id="perfTestXValue" value="0">
                    <label for="perfTestIterations">Number of Iterations:</label>
                    <input type="number" id="perfTestIterations" value="1000">
                    <button onclick="runPerformanceTest()">Start Manual Perf Test</button>
                </div>

                <h2>Manual Function Tests</h2>
                <div class="control-group">
                    <h3>Create Paired Entity</h3>
                    <label for="peXValueInput">X Value (decimal string):</label>
                    <input type="text" id="peXValueInput" value="2">
                    <label for="peNBitsInput">N-bits:</label>
                    <input type="number" id="peNBitsInput" value="3" min="1">
                    <button onclick="runCreatePairedEntity()">Create Paired Entity</button>
                </div>
                <div class="control-group">
                    <h3>Test S_N Membership</h3>
                    <label for="memberXValueInput">X Value (decimal string):</label>
                    <input type="text" id="memberXValueInput" value="18">
                    <label for="memberNBitsInput">Target N-bits:</label>
                    <input type="number" id="memberNBitsInput" value="6" min="1">
                    <button onclick="runIsMember()">Test Membership</button>
                </div>
                <div class="control-group">
                     <h3>Decompose to S_base</h3>
                    <label for="decomposeXValueInput">X Value (decimal string):</label>
                    <input type="text" id="decomposeXValueInput" value="18">
                    <label for="decomposeNBitsInput">Target N-bits:</label>
                    <input type="number" id="decomposeNBitsInput" value="6" min="1">
                    <button onclick="runDecompose()">Decompose</button>
                </div>
                <div class="control-group">
                    <h3>Compose from S_base</h3>
                    <label for="composeComponentsInput">S_base Components (comma-separated decimal strings):</label>
                    <input type="text" id="composeComponentsInput" value="2,2">
                    <button onclick="runCompose()">Compose</button>
                </div>
                <div class="control-group">
                    <h3>Generate Random S_N Member</h3>
                    <label for="randomNBitsInput">Target N-bits:</label>
                    <input type="number" id="randomNBitsInput" value="6" min="1">
                    <label for="randomSeedOffsetInput">Seed Offset (for PRNG consistency):</label>
                    <input type="number" id="randomSeedOffsetInput" value="0">
                    <button onclick="runGenerateRandom()">Generate Random</button>
                </div>
            </div>
        </details>

        <div id="fullLogContainer">
            <h2>Verbose Log</h2>
            <div class="log-controls">
                <button onclick="toggleFullLog()" class="secondary-action">Toggle Full Log Display</button>
                <button onclick="exportFullLog()" class="secondary-action">Export Full Log</button>
                <button onclick="clearFullLog()" class="secondary-action">Clear Full Log</button>
            </div>
            <textarea id="fullOutputLog" readonly></textarea>
        </div>
    </div>

    <script type="module">
        import init, { 
            setup_propagator, 
            is_member, 
            decompose_to_base, 
            compose_from_base,
            generate_random_member,
            create_paired_entity 
        } from './pkg/paired_binary.js';

        const mainOutputArea = document.getElementById('mainOutputArea');
        const benchmarkResultArea = document.getElementById('benchmarkResultArea');
        const fullOutputLog = document.getElementById('fullOutputLog');
        const wasmStatusDiv = document.getElementById('wasmStatus');
        const s6SvgElement = document.getElementById('s6Svg');
        const SVG_NS = "http://www.w3.org/2000/svg";

        let wasmInitialized = false;
        let currentSBaseForDisplay = "0,1,2"; 
        let currentNBaseForDisplay = 3;
        let isBenchmarking = false;

        function displayMain(message, type = "info") {
            mainOutputArea.innerHTML = `<p class="status-indicator status-${type}">${message}</p>`;
            if (type === "error") console.error("MainDisplay:", message);
            else console.log("MainDisplay:", message);
        }

        function verboseLog(message, context = "Generic") {
            console.log(`[${context}]`, message);
            const timestamp = new Date().toLocaleTimeString();
            const currentLogVal = fullOutputLog.value;
            const maxLogLength = 50000; 
            const entry = `${timestamp}: [${context}] ${typeof message === 'string' ? message : JSON.stringify(message, null, 2)}\n\n`;
            fullOutputLog.value = (currentLogVal + entry).slice(-maxLogLength);
            if (fullOutputLog.style.display !== 'none') {
                fullOutputLog.scrollTop = fullOutputLog.scrollHeight;
            }
        }
        
        async function initializeWasm() {
            // ... (same as previous version)
            if (wasmInitialized) return true;
            wasmStatusDiv.textContent = "Loading WASM...";
            wasmStatusDiv.className = "status-indicator status-info";
            try {
                await init(); 
                wasmStatusDiv.textContent = "WASM Module Initialized Successfully.";
                wasmStatusDiv.className = "status-indicator status-ok";
                verboseLog("WASM module initialized successfully.", "System");
                wasmInitialized = true;
                try { // Setup default propagator
                    setup_propagator("0,1,2", 3); 
                    currentSBaseForDisplay = "0,1,2";
                    currentNBaseForDisplay = 3;
                    verboseLog("Default propagator S3={0,1,2} initialized.", "System");
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`Error setting up default propagator: ${errorStr}`, "System");
                    displayMain(`Error setting up default propagator: ${errorStr}`, "error");
                }
                return true;
            } catch (e) {
                wasmStatusDiv.textContent = "WASM Initialization Failed! Check console.";
                wasmStatusDiv.className = "status-indicator status-error";
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                verboseLog(`WASM Initialization Failed: ${errorStr}`, "System");
                wasmInitialized = false;
                return false;
            }
        }
        
        window.setupWasmPropagator = async () => { 
            // ... (same as previous, but uses displayMain and verboseLog)
            if (!await initializeWasm()) return;
            const sBaseValuesStr = document.getElementById('sBaseValuesInput').value;
            const nBaseBits = parseInt(document.getElementById('nBaseBitsInput').value);
            currentSBaseForDisplay = sBaseValuesStr; 
            currentNBaseForDisplay = nBaseBits;
            try {
                setup_propagator(sBaseValuesStr, nBaseBits);
                displayMain(`Propagator initialized/updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "ok");
                verboseLog(`Propagator user-updated: S_base='${sBaseValuesStr}', N_base=${nBaseBits}`, "Setup");
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`Setup Propagator Error: ${errorStr}`, "error");
                verboseLog(`Error setting up propagator: ${errorStr}`, "Setup");
            }
        };
        
        async function runWasmOpForDisplay(actionName, operationFunc, ...args) {
            // ... (same as previous)
            if (!await initializeWasm()) return "WASM not ready";
            displayMain(`${actionName}: Processing...`, "info");
            const startTime = performance.now();
            try {
                const result = await operationFunc(...args); 
                const endTime = performance.now();
                const timedResult = { result: result, time_ms: (endTime - startTime).toFixed(3) };
                displayMain(`${actionName} Complete.`, "ok"); // Display concise success
                verboseLog({action: actionName, inputs: args.map(String), ...timedResult}, "ManualOp"); // Verbose log with details
                return result; 
            } catch (e) {
                const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                displayMain(`${actionName} Error: ${errorStr}`, "error");
                verboseLog(`Error in ${actionName}: ${errorStr}`, "ManualOp");
                throw e; 
            }
        }

        window.runCreatePairedEntity = () => { /* ... same as previous (uses runWasmOpForDisplay) ... */ 
            const x = document.getElementById('peXValueInput').value;
            const n = parseInt(document.getElementById('peNBitsInput').value);
            runWasmOpForDisplay("CreatePairedEntity", create_paired_entity, x, n);
        };
        window.runIsMember = () => {  /* ... same as previous (uses runWasmOpForDisplay) ... */
            const x = document.getElementById('memberXValueInput').value;
            const n = parseInt(document.getElementById('memberNBitsInput').value);
            runWasmOpForDisplay("IsMember", is_member, x, n);
        };
        window.runDecompose = async () => { /* ... same as previous (uses runWasmOpForDisplay) ... */
            const x = document.getElementById('decomposeXValueInput').value;
            const n = parseInt(document.getElementById('decomposeNBitsInput').value);
            await runWasmOpForDisplay("Decompose", async (val, bits) => {
                 const wasm_array = decompose_to_base(val, bits);
                 const nativeJsArray = Array.from(wasm_array);
                 return nativeJsArray.map(jsVal => (typeof jsVal === 'string') ? jsVal : (jsVal && typeof jsVal.as_string === 'function') ? jsVal.as_string() : String(jsVal));
            }, x, n);
        };
        window.runCompose = () => { /* ... same as previous (uses runWasmOpForDisplay) ... */
            const compsStr = document.getElementById('composeComponentsInput').value;
            const compsArr = compsStr.split(',').map(s => s.trim()).filter(s => s.length > 0);
            runWasmOpForDisplay("Compose", compose_from_base, compsArr);
        };
        window.runGenerateRandom = () => { /* ... same as previous (uses runWasmOpForDisplay) ... */
            const n = parseInt(document.getElementById('randomNBitsInput').value);
            const seed = parseInt(document.getElementById('randomSeedOffsetInput').value);
            runWasmOpForDisplay("GenerateRandom", generate_random_member, n, seed);
        };

        window.runAutomatedTests = async () => { /* ... (same test logic, but uses verboseLog for details, and displayMain for summary) ... */
            if (!await initializeWasm()) return;
            displayMain("Automated Tests", "Running... Check verbose log for details.", "info");
            verboseLog("Starting Automated Basic Test Suite...", "TestRunner");
            try { setup_propagator("0,1,2", 3); } catch(e) { verboseLog("Failed to set S3={0,1,2} for tests", "TestRunner"); displayMain("Automated Tests Error: Could not set S3.", "error"); return;}

            const tests = [ /* ... same tests ... */
                { name: "PE_N3_X2", func: () => create_paired_entity("2", 3), expect: (r) => r.x === "2" && r.x_prime === "5" && r.n_bits === 3 },
                { name: "IsMember_S6_18_True", func: () => is_member("18", 6), expect: (r) => r === true },
                { name: "Decompose_S6_18", func: () => decompose_to_base("18", 6), expect: (r_arr) => Array.from(r_arr).map(v=>v.toString()).join(',') === "2,2" },
                { name: "Compose_S6_From_[2,2]", func: () => compose_from_base(["2","2"]), expect: (r) => r.value === "18" && r.n_bits === 6 },
                { name: "GenRandom_S6_Valid", func: async () => { const r_str = await generate_random_member(6, 10); return {randomVal: r_str, isMember: await is_member(r_str, 6)}; }, expect: (res) => res.isMember === true && !isNaN(parseInt(res.randomVal)) },
            ];
            let testsPassed = 0; let testsFailed = 0;
            const suiteStartTime = performance.now();
            for (const test of tests) { /* ... (same execution logic, use verboseLog) ... */
                verboseLog(`Running test: ${test.name}`, "TestRunner");
                let result, errorOccurred = false, actualError = null;
                try { result = await test.func(); } 
                catch (e) { errorOccurred = true; actualError = e; }

                if (test.expectError) {
                    if (errorOccurred) { verboseLog(`PASS: ${test.name}`, "TestRunner"); testsPassed++; } 
                    else { verboseLog(`FAIL: ${test.name} - Expected error, got success: ${JSON.stringify(result)}`, "TestRunner"); testsFailed++; }
                } else {
                    if (errorOccurred) { verboseLog(`FAIL: ${test.name} - Expected success, got error: ${String(actualError)}`, "TestRunner"); testsFailed++; } 
                    else {
                        let assertionPassed = false; try { assertionPassed = test.expect(result); } catch (ae) { verboseLog(`FAIL: ${test.name} - Assertion func error: ${ae}`, "TestRunner");}
                        if (assertionPassed) { verboseLog(`PASS: ${test.name}`, "TestRunner"); testsPassed++; } 
                        else { verboseLog(`FAIL: ${test.name} - Assertion failed. Got: ${JSON.stringify(result)}`, "TestRunner"); testsFailed++; }
                    }
                }
            }
            const suiteEndTime = performance.now();
            const totalSuiteTime = (suiteEndTime - suiteStartTime).toFixed(3);
            const summary = `Test Suite: ${testsPassed} passed, ${testsFailed} failed in ${totalSuiteTime} ms.`;
            displayMain("Automated Tests", summary + (testsFailed > 0 ? " Check verbose log for details." : " All OK!"), testsFailed > 0 ? "error" : "ok");
            verboseLog(summary, "TestRunner");
        };
        
        window.runDepthTest = async () => { /* ... same as previous improved version, uses displayMain for summary and benchmarkResultArea ... */
            if (!await initializeWasm()) return;
            if (isBenchmarking) { displayMain("Depth Test", "Benchmark already in progress.", "info"); return; }
            isBenchmarking = true;
            const depthTestButton = document.getElementById("depthTestButton");
            depthTestButton.disabled = true; depthTestButton.textContent = "Running Depth Test...";
            benchmarkResultArea.innerHTML = "<p><i>Running depth test... This may take some time. Please wait.</i></p>";
            verboseLog("Starting Max N Depth Test...", "DepthTest");

            const requiredSBase = "0,1,2"; const requiredNBase = 3;
            if (currentSBaseForDisplay !== requiredSBase || currentNBaseForDisplay !== requiredNBase) {
                try { setup_propagator(requiredSBase, requiredNBase); currentSBaseForDisplay = requiredSBase; currentNBaseForDisplay = requiredNBase;
                    verboseLog(`Propagator reset to S_base=${requiredSBase}, N_base=${requiredNBase} for depth test.`, "DepthTest-Setup");
                } catch(e) { /* ... error handling ... */ benchmarkResultArea.innerHTML = `<p>Error setting up S3={0,1,2} for test: ${e}</p>`; isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test"; return;}
            }

            const timeLimitMs = parseInt(document.getElementById('depthTestTimeLimit').value) || 500;
            let currentN = requiredNBase * 2; 
            let maxNReached = 0; let results = [];
            const practicalBrowserNLimit = 4096; 

            while (currentN <= practicalBrowserNLimit) {
                verboseLog(`DepthTest: Testing N=${currentN}`, "DepthTest");
                let xValStr; let duration = 0; let isMem = false; let testPassedThisN = false;
                try {
                    const stepStartTime = performance.now();
                    xValStr = await generate_random_member(currentN, Date.now() % 1000 + currentN); 
                    if (typeof xValStr !== 'string' || xValStr.length === 0) throw new Error("generate_random_member invalid output.");
                    isMem = await is_member(xValStr, currentN);
                    const stepEndTime = performance.now();
                    duration = stepEndTime - stepStartTime;
                    const xPreview = xValStr.length > 20 ? xValStr.slice(0, 20) + "..." : xValStr;
                    results.push({ N: currentN, time_ms: duration.toFixed(3), is_member_result: isMem, generated_x_preview: xPreview });
                    if (duration <= timeLimitMs) { maxNReached = currentN; testPassedThisN = true; } 
                    else { verboseLog(`DepthTest: N=${currentN} exceeded time limit (${duration.toFixed(2)}ms > ${timeLimitMs}ms). Stopping.`, "DepthTest"); break; }
                } catch (e) {
                    const errorStr = (e instanceof Error) ? `${e.name}: ${e.message}` : String(e);
                    verboseLog(`DepthTest: Error at N=${currentN}: ${errorStr}`, "DepthTest");
                    results.push({ N: currentN, time_ms: duration.toFixed(3), error: errorStr, generated_x_preview: "ERROR_DURING_GEN/TEST" });
                    if (!errorStr.includes("InvalidHierarchicalLevel")) { maxNReached = currentN > requiredNBase ? currentN / 2 : 0; verboseLog(`DepthTest: Stopping due to error at N=${currentN}. Last potentially successful N for generation was ${maxNReached}.`, "DepthTest"); break; }
                }
                if (!testPassedThisN) break; 
                if (currentN >= practicalBrowserNLimit / 2 && currentN < practicalBrowserNLimit) { if (currentN * 2 > practicalBrowserNLimit) break; }
                currentN *= 2; 
            }
            benchmarkResultArea.innerHTML = `<h3>Depth Test Results (S_base=${requiredSBase}, N_base=${requiredNBase}):</h3> <p>Max N reached for (generate_random + is_member) within ~${timeLimitMs}ms per N: <b>${maxNReached || 'N_base only (or error)'}</b></p> <pre>${JSON.stringify(results, null, 2)}</pre>`;
            verboseLog(`Depth Test Finished. Max N for ~${timeLimitMs}ms: ${maxNReached}`, "DepthTest");
            isBenchmarking = false; depthTestButton.disabled = false; depthTestButton.textContent = "Run Max N Depth Test";
        };
        
        window.runPerformanceTest = async () => { /* ... (same as previous, but use displayMain and verboseLog appropriately) ... */
            if (!await initializeWasm()) return;
            const funcToTest = document.getElementById('perfTestFunction').value;
            const nValue = parseInt(document.getElementById('perfTestNValue').value);
            let xValueStr = document.getElementById('perfTestXValue').value.trim(); 
            const iterations = parseInt(document.getElementById('perfTestIterations').value);

            if (isNaN(nValue) || isNaN(iterations) || iterations <= 0) {
                displayMain("Performance Test", "Invalid N value or iterations.", "error");
                verboseLog("Invalid N value or iterations for performance test.", "PerfTest"); return;
            }
            displayMain("Performance Test", `Running ${funcToTest} for N=${nValue}, ${iterations} iterations...`, "info");
            verboseLog(`Starting Performance Test: ${funcToTest}, N=${nValue}, Iterations=${iterations}`, "PerfTest");
            
            let totalTime = 0; let operationSuccess = 0; let operationError = 0;
            let sampleArg1, sampleArg2; 
            let seedOffsetForPerfTest = Date.now() % 1000; // Initialize seed offset

            try { /* ... (same argument prep logic) ... */
                 if (funcToTest === "is_member" || funcToTest === "decompose_to_base" || funcToTest === "create_paired_entity") {
                    if (!xValueStr && (funcToTest === "is_member" || funcToTest === "decompose_to_base")) { 
                         verboseLog("PerfTest: No X value for is_member/decompose, generating random...", "PerfTest-Setup");
                         xValueStr = await generate_random_member(nValue, seedOffsetForPerfTest++); 
                         verboseLog(`PerfTest: Generated X = ${xValueStr.slice(0,20)}... for N=${nValue}`, "PerfTest-Setup");
                    } else if (!xValueStr && funcToTest === "create_paired_entity") { xValueStr = "0"; verboseLog(`PerfTest: No X value for create_paired_entity, using "0".`, "PerfTest-Setup");}
                    sampleArg1 = xValueStr; sampleArg2 = nValue;
                } else if (funcToTest === "compose_from_base") {
                    const numLevelsRecursion = Math.log2(nValue / currentNBaseForDisplay);
                    if (isNaN(numLevelsRecursion) || !Number.isInteger(numLevelsRecursion) || numLevelsRecursion < 0) { throw new Error(`Cannot determine base components for N=${nValue} from N_base=${currentNBaseForDisplay}`); }
                    const numBaseComponents = Math.pow(2, numLevelsRecursion);
                    const sBaseArray = currentSBaseForDisplay.split(',').map(s => s.trim());
                    if (sBaseArray.length === 0) { throw new Error(`S_Base is empty for compose test.`);}
                    let tempSampleArg1 = [];
                    for(let i=0; i<numBaseComponents; i++) tempSampleArg1.push(sBaseArray[i % sBaseArray.length]); 
                    sampleArg1 = tempSampleArg1; 
                } else if (funcToTest === "generate_random_member") { sampleArg1 = nValue; sampleArg2 = 0; } 
                else { throw new Error(`Unknown function for performance test: ${funcToTest}`);}
            } catch (e) { const errText = `Error preparing args for ${funcToTest}: ${e}`; displayMain("Performance Test", errText, "error"); verboseLog(errText, "PerfTest-Setup"); return;}

            const overallStartTime = performance.now();
            for (let i = 0; i < iterations; i++) { /* ... (same timing loop) ... */
                const iterStartTime = performance.now();
                try {
                    switch (funcToTest) {
                        case "is_member": is_member(sampleArg1, sampleArg2); break;
                        case "decompose_to_base": decompose_to_base(sampleArg1, sampleArg2); break;
                        case "compose_from_base": compose_from_base(sampleArg1); break; 
                        case "generate_random_member": generate_random_member(sampleArg1, i + seedOffsetForPerfTest); break; 
                        case "create_paired_entity": create_paired_entity(sampleArg1, sampleArg2); break;
                    }
                    operationSuccess++;
                } catch (e) { operationError++; if (i < 3 && iterations > 10) verboseLog(`PerfTest iter ${i} error: ${e}`, funcToTest); }
                const iterEndTime = performance.now(); totalTime += (iterEndTime - iterStartTime);
            }
            const overallEndTime = performance.now();
            const perfResults = { /* ... same results object ... */
                action: `PerformanceTest[${funcToTest}]`,
                inputs: { N: nValue, X_val_used: (funcToTest !== "compose_from_base" && funcToTest !== "generate_random_member") ? String(sampleArg1).slice(0,20) + "..." : "N/A", iterations: iterations },
                total_js_loop_time_ms: (overallEndTime - overallStartTime).toFixed(3),
                total_wasm_calls_time_ms: totalTime.toFixed(3),
                avg_wasm_call_time_ms: (iterations > 0 ? totalTime / iterations : 0).toFixed(5),
                successes: operationSuccess, errors: operationError
            };
            displayMain("Performance Test", perfResults, false);
            verboseLog(perfResults, "PerfTest");
        };
        
        window.drawS6VisualizationSVG = async () => {
            if (!await initializeWasm()) return;

            // Ensure S3={0,1,2} for this specific visualization
            const requiredSBase = "0,1,2"; const requiredNBase = 3;
            if (currentSBaseForDisplay !== requiredSBase || currentNBaseForDisplay !== requiredNBase) {
                try { setup_propagator(requiredSBase, requiredNBase); currentSBaseForDisplay = requiredSBase; currentNBaseForDisplay = requiredNBase;
                     verboseLog(`Propagator reset to S_base=${requiredSBase}, N_base=${requiredNBase} for S6 Viz.`, "S6Viz-Setup");
                } catch(e) { displayMain("S6 Viz Error: Could not set S3.", "error"); verboseLog(`Failed to set S3={0,1,2} for S6 Viz: ${e}`, "S6Viz-Setup"); return;}
            }
            
            s6SvgElement.innerHTML = ''; // Clear previous SVG content
            const s3Values = [0, 1, 2]; 
            const s6Members = []; 

            for (const h_upper of s3Values) {
                for (const h_lower of s3Values) {
                    try {
                        const composed = compose_from_base([String(h_upper), String(h_lower)]);
                        if (composed && typeof composed.value === 'string' && typeof composed.n_bits === 'number' && composed.n_bits === 6) {
                             s6Members.push({ x_val: parseInt(composed.value), h_upper: h_upper, h_lower: h_lower });
                        } else { verboseLog(`Unexpected compose result for (${h_upper},${h_lower}): ${JSON.stringify(composed)}`, "S6Viz-Setup");}
                    } catch (e) { verboseLog(`Error composing S6 member for (${h_upper},${h_lower}): ${e}`, "S6Viz-Setup");}
                }
            }

            if (s6Members.length !== 9) {
                displayMain("S6 Visualization", `Generated ${s6Members.length}/9 S6 members. Plot may be incomplete.`, "error");
                verboseLog(`Expected 9 S6 members for S3={0,1,2}, but generated ${s6Members.length}.`, "S6Viz");
            }

            const width = parseInt(s6SvgElement.getAttribute('width'));
            const height = parseInt(s6SvgElement.getAttribute('height'));
            const gridSize = 3; 
            const cellPadding = 40;
            const cellSize = (width - 2 * cellPadding) / gridSize;
            const radius = Math.min(18, cellSize / 3.5); 
            
            verboseLog(`Plotting ${s6Members.length} S6 members using SVG.`, "S6Viz");

            // Draw grid lines (optional)
            for(let i = 0; i <= gridSize; i++) {
                let line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', cellPadding + i * cellSize); line.setAttribute('y1', cellPadding);
                line.setAttribute('x2', cellPadding + i * cellSize); line.setAttribute('y2', cellPadding + gridSize * cellSize);
                line.setAttribute('stroke', '#e0e0e0'); line.setAttribute('stroke-width', '0.5');
                s6SvgElement.appendChild(line);
                line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', cellPadding); line.setAttribute('y1', cellPadding + i * cellSize);
                line.setAttribute('x2', cellPadding + gridSize * cellSize); line.setAttribute('y2', cellPadding + i * cellSize);
                line.setAttribute('stroke', '#e0e0e0'); line.setAttribute('stroke-width', '0.5');
                s6SvgElement.appendChild(line);
            }

            s6Members.forEach(member => {
                const cx = cellPadding + (member.h_upper * cellSize) + cellSize / 2;
                const cy = cellPadding + (member.h_lower * cellSize) + cellSize / 2;

                const circle = document.createElementNS(SVG_NS, 'circle');
                circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
                circle.setAttribute('r', radius);
                
                const sumComps = member.h_upper + member.h_lower;
                let fillColor = 'rgba(200, 200, 200, 0.7)'; // Default grey
                if (sumComps <= 1) fillColor = 'rgba(135, 206, 250, 0.8)'; // LightSkyBlue
                else if (sumComps <= 3) fillColor = 'rgba(152, 251, 152, 0.8)'; // PaleGreen
                else fillColor = 'rgba(255, 182, 193, 0.8)'; // LightPink
                
                circle.setAttribute('fill', fillColor);
                circle.setAttribute('stroke', '#444');
                circle.setAttribute('stroke-width', '1.5');
                s6SvgElement.appendChild(circle);

                const text = document.createElementNS(SVG_NS, 'text');
                text.setAttribute('x', cx); text.setAttribute('y', cy);
                text.setAttribute('dy', '.3em'); // Vertical alignment
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '10px');
                text.setAttribute('fill', '#000');
                text.textContent = String(member.x_val);
                s6SvgElement.appendChild(text);
            });
             displayMain("S6 Visualization", `Plotted ${s6Members.length} S6 members using SVG.`, "ok");
        };
        
        window.toggleFullLog = () => { /* ... same as before ... */ 
            fullOutputLog.style.display = (fullOutputLog.style.display === 'none' || fullOutputLog.style.display === '') ? 'block' : 'none';
            if (fullOutputLog.style.display === 'block') fullOutputLog.scrollTop = fullOutputLog.scrollHeight;
        };
        window.exportFullLog = () => { /* ... same as before ... */
             const blob = new Blob([fullOutputLog.value], { type: 'text/plain' }); const anchor = document.createElement('a');
             anchor.download = 'paired_binary_log.txt'; anchor.href = URL.createObjectURL(blob);
             anchor.click(); URL.revokeObjectURL(anchor.href);
         };
        window.clearFullLog = () => { fullOutputLog.value = ''; };

        initializeWasm();
    </script>
</body>
</html>
